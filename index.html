<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SweetPrinceLedger</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%91%91%3C/text%3E%3C/svg%3E">
    <link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%91%91%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="./constants.js"></script>
    <script src="./utils.js"></script>
    <script src="./market-api.js"></script>
    <script src="./data-utils.js"></script>
    <script src="./report-export.js"></script>
    <script src="./cloud-sync.js"></script>
    <script src="./cashflow-engine.js"></script>
    <script src="./cashflow-apply.js"></script>
    <script src="./cashflow-rules.js"></script>
    <script src="./cashflow-form.js"></script>
    <script src="./asset-actions.js"></script>
    <script type="text/babel" src="./date-picker-view.js"></script>
    <script type="text/babel" src="./app-header-status-view.js"></script>
    <script type="text/babel" src="./app-header-view.js"></script>
    <script type="text/babel" src="./app-footer-view.js"></script>
    <script type="text/babel" src="./overview-section-view.js"></script>
    <script type="text/babel" src="./finance-section-view.js"></script>
    <script type="text/babel" src="./asset-filter-bar-view.js"></script>
    <script type="text/babel" src="./asset-summary-list-view.js"></script>
    <script type="text/babel" src="./asset-detail-list-view.js"></script>
    <script type="text/babel" src="./app-status-messages.js"></script>
    <script type="text/babel" src="./app-style-helpers.js"></script>
    <script type="text/babel" src="./app-modals-view.js"></script>
    <script type="text/babel" src="./cashflow-modal-view.js"></script>
    <script type="text/babel" src="./cashflow-form-view.js"></script>
    <script type="text/babel" src="./cashflow-overview-view.js"></script>
    <script type="text/babel" src="./cashflow-rules-view.js"></script>
    <script type="text/babel" src="./asset-modal-view.js"></script>
    <script src="./market-sync.js"></script>
    <script src="./fx-sync.js"></script>
    <script src="./cloud-state-apply.js"></script>
    <script src="./theme-system.js"></script>
    <!-- Lucide 圖標 -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="./i18n.js"></script>
    <link rel="stylesheet" href="./theme-bridge.css">
    <link rel="stylesheet" href="./app-shell.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        const {
            CURRENCIES,
            DEFAULT_RATES,
            STORAGE_KEYS,
            FIREBASE_CONFIG,
            CLOUD_COLLECTION,
            hasFirebaseConfig,
            firebaseApp,
            firebaseAuth,
            firebaseDB,
            isCloudEnabled,
            CATEGORIES,
            CRYPTO_ID_MAP,
            CATEGORY_KEYS,
            CASHFLOW_TYPES,
            CASHFLOW_SCHEDULE_TYPES,
            CASHFLOW_FREQUENCIES,
            WEEKDAY_LABELS,
            CASHFLOW_CATEGORY_OPTIONS,
            CASHFLOW_CATEGORY_BY_TYPE,
            getDefaultCashflowCategory,
            ONE_DAY_MS
        } = window.APP_CONSTANTS || {};
        if (!CURRENCIES || !DEFAULT_RATES || !STORAGE_KEYS || !CATEGORIES || !CASHFLOW_TYPES) {
            throw new Error('constants.js is missing or incomplete.');
        }
        const {
            PAGE_LANGUAGE_OPTIONS,
            UI_TEXT,
            FULL_PAGE_TEXT_MAP,
            HEADER_SLOGANS,
            IDLE_HINT_LINES,
            THEME_NAME_MAP
        } = window.APP_I18N || {};
        if (!PAGE_LANGUAGE_OPTIONS || !UI_TEXT || !FULL_PAGE_TEXT_MAP || !HEADER_SLOGANS || !IDLE_HINT_LINES || !THEME_NAME_MAP) {
            throw new Error('i18n.js is missing or incomplete.');
        }
        const {
            polarToCartesian,
            describeArc,
            seedAssets,
            parseStorage,
            sanitizeCurrencyRates,
            toHKD,
            fromHKD,
            formatAmount,
            getNetWorthTier,
            calculateMortgageMetrics,
            calculateInstallmentLoanMetrics,
            calculateFixedDepositMetrics,
            calculateBankWealthMetrics,
            pad2,
            toDateKey,
            toMonthKey,
            parseDateKey,
            normalizeDateKeyOrFallback,
            parseOccurrenceDateFromPostingKey,
            sanitizeCashflowEntries,
            isEntryOnDate,
            findNextOccurrenceDateKey,
            findLastOccurrenceDateKey,
            ensureJsPdfReady,
            ensureHtml2CanvasReady
        } = window.APP_UTILS || {};
        if (!polarToCartesian || !describeArc || !parseStorage || !sanitizeCurrencyRates || !toDateKey || !parseDateKey || !sanitizeCashflowEntries || !ensureJsPdfReady || !ensureHtml2CanvasReady) {
            throw new Error('utils.js is missing or incomplete.');
        }

        const {
            normalizeYahooSymbol,
            fetchLatestCurrencyRates,
            fetchYahooQuotes,
            fetchCryptoQuotes
        } = window.APP_MARKET_API || {};
        if (!normalizeYahooSymbol || !fetchLatestCurrencyRates || !fetchYahooQuotes || !fetchCryptoQuotes) {
            throw new Error('market-api.js is missing or incomplete.');
        }

        const {
            normalizeAssetRecord,
            isValidAssetRecord,
            isValidCashflowRecord,
            buildBackupPayload,
            downloadJsonFile,
            parseImportedBackup
        } = window.APP_DATA_UTILS || {};
        if (!normalizeAssetRecord || !isValidAssetRecord || !isValidCashflowRecord || !buildBackupPayload || !downloadJsonFile || !parseImportedBackup) {
            throw new Error('data-utils.js is missing or incomplete.');
        }

        const {
            exportAssetReportPdf
        } = window.APP_REPORT_EXPORT || {};
        if (!exportAssetReportPdf) {
            throw new Error('report-export.js is missing or incomplete.');
        }

        const {
            buildCloudSyncPayload,
            downloadCloudData,
            uploadCloudData,
            loginWithGoogle,
            logoutGoogle
        } = window.APP_CLOUD_SYNC || {};
        if (!buildCloudSyncPayload || !downloadCloudData || !uploadCloudData || !loginWithGoogle || !logoutGoogle) {
            throw new Error('cloud-sync.js is missing or incomplete.');
        }

        const {
            buildCashflowMonthData,
            buildCashflowYearData
        } = window.APP_CASHFLOW_ENGINE || {};
        if (!buildCashflowMonthData || !buildCashflowYearData) {
            throw new Error('cashflow-engine.js is missing or incomplete.');
        }

        const {
            applyAutoCashflowPostings
        } = window.APP_CASHFLOW_APPLY || {};
        if (!applyAutoCashflowPostings) {
            throw new Error('cashflow-apply.js is missing or incomplete.');
        }

        const {
            collectCashflowDeleteContext,
            rollbackCashflowPostingsOnLiquidAssets
        } = window.APP_CASHFLOW_RULES || {};
        if (!collectCashflowDeleteContext || !rollbackCashflowPostingsOnLiquidAssets) {
            throw new Error('cashflow-rules.js is missing or incomplete.');
        }

        const {
            buildCashflowSubmission,
            buildCashflowSubmitStatus,
            buildCashflowFormFromEntry
        } = window.APP_CASHFLOW_FORM || {};
        if (!buildCashflowSubmission || !buildCashflowSubmitStatus || !buildCashflowFormFromEntry) {
            throw new Error('cashflow-form.js is missing or incomplete.');
        }

        const {
            buildAssetSubmission,
            buildAssetDeleteResult
        } = window.APP_ASSET_ACTIONS || {};
        if (!buildAssetSubmission || !buildAssetDeleteResult) {
            throw new Error('asset-actions.js is missing or incomplete.');
        }

        const {
            CashflowRuleForm
        } = window.APP_CASHFLOW_FORM_VIEW || {};
        if (!CashflowRuleForm) {
            throw new Error('cashflow-form-view.js is missing or incomplete.');
        }

        const {
            CashflowModalView
        } = window.APP_CASHFLOW_MODAL_VIEW || {};
        if (!CashflowModalView) {
            throw new Error('cashflow-modal-view.js is missing or incomplete.');
        }

        const {
            AppHeaderView
        } = window.APP_HEADER_VIEW || {};
        if (!AppHeaderView) {
            throw new Error('app-header-view.js is missing or incomplete.');
        }

        const {
            AppFooterView
        } = window.APP_FOOTER_VIEW || {};
        if (!AppFooterView) {
            throw new Error('app-footer-view.js is missing or incomplete.');
        }

        const {
            OverviewSectionView
        } = window.APP_OVERVIEW_SECTION_VIEW || {};
        if (!OverviewSectionView) {
            throw new Error('overview-section-view.js is missing or incomplete.');
        }

        const {
            FinanceSectionView
        } = window.APP_FINANCE_SECTION_VIEW || {};
        if (!FinanceSectionView) {
            throw new Error('finance-section-view.js is missing or incomplete.');
        }

        const {
            AssetFilterBarView
        } = window.APP_ASSET_FILTER_BAR_VIEW || {};
        if (!AssetFilterBarView) {
            throw new Error('asset-filter-bar-view.js is missing or incomplete.');
        }

        const {
            AssetSummaryListView
        } = window.APP_ASSET_SUMMARY_LIST_VIEW || {};
        if (!AssetSummaryListView) {
            throw new Error('asset-summary-list-view.js is missing or incomplete.');
        }

        const {
            AssetDetailListView
        } = window.APP_ASSET_DETAIL_LIST_VIEW || {};
        if (!AssetDetailListView) {
            throw new Error('asset-detail-list-view.js is missing or incomplete.');
        }

        const {
            getPrinceHintMessage,
            getPdfGeneratingBusyMessage,
            getPdfTimeoutMessage,
            getCashflowStartNewMessage,
            getCashflowStartEditMessage,
            getCashflowAutoAppliedMessage,
            getCashflowDeleteRollbackMessage,
            getCashflowDeleteMessage,
            getCashflowLinkedAccountLabel,
            getCashflowDeleteConfirmMessage,
            getCashflowEditCanceledMessage,
            getFxUpdatingMessage,
            getFxUpdatedMessage,
            getFxUpdateFailedMessage,
            getMarketNoSymbolsMessage,
            getMarketUpdatingMessage,
            getMarketUpdatedCountMessage,
            getMarketUpToDateMessage,
            getMarketAndFxUpdatingMessage,
            getMarketAndFxUpdatedMessage,
            getExportSuccessMessage,
            getExportFailedMessage,
            getPdfDownloadedMessage,
            getPdfShareFailedMessage,
            getImportSuccessMessage,
            getImportFailedMessage,
            getDataResetMessage,
            getResetSeedConfirmMessage,
            showSubmissionErrorAlert,
            showConfirmDialog,
            getCloudAuthStatusMessage,
            getCloudPersistenceFailedMessage,
            getCloudRedirectSignInFailedMessage,
            getCloudRedirectUriMismatchHelpMessage,
            getCloudFirebaseNotConfiguredMessage,
            getCloudSignInRequiredMessage,
            getCloudDownloadingMessage,
            getCloudDownloadedMessage,
            getCloudInvalidDataMessage,
            getCloudNoDataMessage,
            getCloudDownloadFailedMessage,
            getCloudUploadingMessage,
            getCloudUploadedMessage,
            getCloudUploadFailedMessage
        } = window.APP_STATUS_MESSAGES || {};
        if (!getPrinceHintMessage || !getPdfGeneratingBusyMessage || !getPdfTimeoutMessage || !getCashflowStartNewMessage || !getCashflowStartEditMessage || !getCashflowAutoAppliedMessage || !getCashflowDeleteRollbackMessage || !getCashflowDeleteMessage || !getCashflowLinkedAccountLabel || !getCashflowDeleteConfirmMessage || !getCashflowEditCanceledMessage || !getFxUpdatingMessage || !getFxUpdatedMessage || !getFxUpdateFailedMessage || !getMarketNoSymbolsMessage || !getMarketUpdatingMessage || !getMarketUpdatedCountMessage || !getMarketUpToDateMessage || !getMarketAndFxUpdatingMessage || !getMarketAndFxUpdatedMessage || !getExportSuccessMessage || !getExportFailedMessage || !getPdfDownloadedMessage || !getPdfShareFailedMessage || !getImportSuccessMessage || !getImportFailedMessage || !getDataResetMessage || !getResetSeedConfirmMessage || !showSubmissionErrorAlert || !showConfirmDialog || !getCloudAuthStatusMessage || !getCloudPersistenceFailedMessage || !getCloudRedirectSignInFailedMessage || !getCloudRedirectUriMismatchHelpMessage || !getCloudFirebaseNotConfiguredMessage || !getCloudSignInRequiredMessage || !getCloudDownloadingMessage || !getCloudDownloadedMessage || !getCloudInvalidDataMessage || !getCloudNoDataMessage || !getCloudDownloadFailedMessage || !getCloudUploadingMessage || !getCloudUploadedMessage || !getCloudUploadFailedMessage) {
            throw new Error('app-status-messages.js is missing or incomplete.');
        }

        const {
            resolveThemeFamily,
            buildNetworthCardStyle,
            buildSummaryCardStyle,
            buildMixSelectedStyle,
            buildCategoryChipStyle,
            getCategoryMixHexByTheme,
            getDetailMixPaletteByTheme
        } = window.APP_STYLE_HELPERS || {};
        if (!resolveThemeFamily || !buildNetworthCardStyle || !buildSummaryCardStyle || !buildMixSelectedStyle || !buildCategoryChipStyle || !getCategoryMixHexByTheme || !getDetailMixPaletteByTheme) {
            throw new Error('app-style-helpers.js is missing or incomplete.');
        }

        const {
            AppModalsView
        } = window.APP_MODALS_VIEW || {};
        if (!AppModalsView) {
            throw new Error('app-modals-view.js is missing or incomplete.');
        }

        const {
            CashflowOverviewView
        } = window.APP_CASHFLOW_OVERVIEW_VIEW || {};
        if (!CashflowOverviewView) {
            throw new Error('cashflow-overview-view.js is missing or incomplete.');
        }

        const {
            CashflowRulesView
        } = window.APP_CASHFLOW_RULES_VIEW || {};
        if (!CashflowRulesView) {
            throw new Error('cashflow-rules-view.js is missing or incomplete.');
        }

        const {
            AssetModalView
        } = window.APP_ASSET_MODAL_VIEW || {};
        if (!AssetModalView) {
            throw new Error('asset-modal-view.js is missing or incomplete.');
        }

        const {
            DatePicker,
            MonthPicker
        } = window.APP_DATE_PICKER || {};
        if (!DatePicker || !MonthPicker) {
            throw new Error('date-picker-view.js is missing or incomplete.');
        }

        const {
            buildMarketTargets,
            applyQuotePricesToAssets
        } = window.APP_MARKET_SYNC || {};
        if (!buildMarketTargets || !applyQuotePricesToAssets) {
            throw new Error('market-sync.js is missing or incomplete.');
        }

        const {
            refreshCurrencyRatesWithStamp
        } = window.APP_FX_SYNC || {};
        if (!refreshCurrencyRatesWithStamp) {
            throw new Error('fx-sync.js is missing or incomplete.');
        }

        const {
            applyHydratedCloudSnapshot
        } = window.APP_CLOUD_STATE_APPLY || {};
        if (!applyHydratedCloudSnapshot) {
            throw new Error('cloud-state-apply.js is missing or incomplete.');
        }

        const {
            THEMES,
            applyTheme
        } = window.APP_THEME_SYSTEM || {};
        if (!THEMES || !applyTheme) {
            throw new Error('theme-system.js is missing or incomplete.');
        }

        function App() {
            const INSURANCE_SUBTYPE_GROUPS = {
                HEALTH: ['醫療險', '重大疾病險', '癌症險', '意外險', '失能/長照險', '健康'],
                LIFE_WEALTH: ['定期壽險', '終身壽險', '年金險', '儲蓄險', '投資型壽險', '萬能壽險', '人壽/累積財富', '投資/投資相連']
            };
            const FIELD_LABEL_CLASS = 'text-[10px] font-black theme-text-sub uppercase tracking-widest ml-1';
            const CASHFLOW_INPUT_CLASS = 'w-full p-3 bg-white rounded-xl font-bold outline-none';
            const CASHFLOW_INPUT_FOCUS_CLASS = `${CASHFLOW_INPUT_CLASS} ring-2 ring-transparent focus:ring-indigo-100`;
            const MODAL_INPUT_CLASS = 'w-full p-3 theme-form-input rounded-xl font-bold';
            const MODAL_INPUT_FOCUS_CLASS = MODAL_INPUT_CLASS;
            const MODAL_OUTPUT_CLASS = 'w-full p-3 theme-form-output rounded-xl font-black';
            const MODAL_GROUP_CLASS = 'theme-form-group';
            const sanitizeRecentCurrencies = (rawList) => {
                if (!Array.isArray(rawList)) return [];
                const unique = [];
                rawList.forEach(item => {
                    const currency = typeof item === 'string' ? item : '';
                    if (!CURRENCIES.includes(currency)) return;
                    if (unique.includes(currency)) return;
                    unique.push(currency);
                });
                return unique.slice(0, 6);
            };
            const [recentCurrencies, setRecentCurrencies] = useState(() => {
                const saved = sanitizeRecentCurrencies(parseStorage(STORAGE_KEYS.recentCurrencies, []));
                if (saved.length) return saved;
                const savedDisplayCurrency = parseStorage(STORAGE_KEYS.displayCurrency, 'HKD');
                return CURRENCIES.includes(savedDisplayCurrency) ? [savedDisplayCurrency] : ['HKD'];
            });
            const markRecentCurrency = (currency) => {
                if (!CURRENCIES.includes(currency)) return;
                setRecentCurrencies(prev => sanitizeRecentCurrencies([currency, ...prev]));
            };
            const orderedCurrencies = useMemo(() => {
                const preferred = sanitizeRecentCurrencies(recentCurrencies);
                const rest = CURRENCIES.filter(currency => !preferred.includes(currency));
                return [...preferred, ...rest];
            }, [recentCurrencies]);
            const updateFormField = (field) => (event) => {
                const value = event.target.value;
                if (field === 'currency') markRecentCurrency(value);
                setFormData(prev => ({ ...prev, [field]: value }));
            };
            const updateFormFieldUpper = (field) => (event) => setFormData(prev => ({ ...prev, [field]: event.target.value.toUpperCase() }));

            const createInitialAssetFormData = () => ({
                account: '',
                name: '',
                category: 'LIQUID',
                subtype: '現金',
                symbol: '',
                quantity: '',
                costBasis: '',
                currency: 'HKD',
                premiumAmount: '',
                insuranceBasePremiumAmount: '',
                insuranceHasSupplementaryBenefit: 'no',
                insuranceSupplementaryPremiumAmount: '',
                insuranceSupplementaryBenefitName: '',
                insuranceSupplementaryBenefitRegion: '',
                insuranceSupplementaryBenefitDeductible: '',
                insuranceInvestmentFundItems: '',
                insuranceInvestmentStrategyNote: '',
                premiumFrequency: 'monthly',
                premiumPaidCount: '',
                insuranceProvider: '',
                insurancePolicyNumber: '',
                insuranceCoverageAmount: '',
                insuranceBeneficiary: '',
                insurancePaymentAccountId: '',
                insurancePaymentDay: '',
                insuranceStartDate: '',
                insuranceEndDate: '',
                insuranceNote: '',
                insuranceWaitingPeriodDays: '',
                insuranceDeductible: '',
                insurancePolicyValue: '',
                insurancePremiumPaymentYears: '',
                insuranceExpectedMaturityDate: '',
                insuranceAnnuityStartDate: '',
                insuranceDistributionStartPolicyYear: '',
                insuranceAnnualDistributionAmount: '',
                insuranceDistributionMode: 'cash',
                insuranceAccumulationRate: '',
                insuranceAccumulationBalance: '',
                insuranceGuaranteedCashValue: '',
                insuranceNonGuaranteedCashValue: '',
                insuranceDistributionPaidYears: '',
                insuranceTotalDistributedAmount: '',
                insuranceProjectedRate: '',
                insuranceFundAllocation: '',
                insurancePartialWithdrawalAmount: '',
                insurancePartialWithdrawalDate: '',
                insurancePartialWithdrawalAccountId: '',
                insurancePartialWithdrawalNote: '',
                insurancePartialWithdrawalEditCashflowId: '',
                propertyPrice: '',
                ltvRatio: '',
                annualInterestRate: '',
                mortgageYears: '',
                paidPeriods: '',
                loanPrincipal: '',
                loanYears: '',
                loanPaidPeriods: '',
                loanAnnualInterestRate: '',
                creditCardBalance: '',
                creditCardMinPayment: '',
                creditCardDueDate: '',
                creditCardAnnualRate: '',
                payableAmount: '',
                payableDueDate: '',
                payableInstallments: '',
                otherOutstanding: '',
                otherAnnualRate: '',
                otherDueDate: '',
                receivableAmount: '',
                receivableDueDate: '',
                receivableInstallments: '',
                receivableParty: '',
                fixedPurchasePrice: '',
                fixedCurrentValue: '',
                fixedPurchaseDate: '',
                fixedNote: '',
                fixedDepositPrincipal: '',
                fixedDepositAnnualRate: '',
                fixedDepositMonths: '',
                fixedDepositStartDate: '',
                fixedDepositTargetLiquidAssetId: '',
                bankWealthPrincipal: '',
                bankWealthGuaranteedAnnualRate: '',
                bankWealthMaxAnnualRate: '',
                bankWealthTermDays: '',
                bankWealthStartDate: '',
                bankWealthMaturityDate: '',
                bankWealthTargetLiquidAssetId: '',
                bankWealthMaturityPayoutMode: 'guaranteed',
                bankWealthMaturityManualAmount: ''
            });
            const ASSET_FORM_DETAIL_RESET_FIELDS = {
                symbol: '',
                quantity: '',
                costBasis: '',
                premiumAmount: '',
                insuranceBasePremiumAmount: '',
                insuranceHasSupplementaryBenefit: 'no',
                insuranceSupplementaryPremiumAmount: '',
                insuranceSupplementaryBenefitName: '',
                insuranceSupplementaryBenefitRegion: '',
                insuranceSupplementaryBenefitDeductible: '',
                insuranceInvestmentFundItems: '',
                insuranceInvestmentStrategyNote: '',
                premiumPaidCount: '',
                premiumFrequency: 'monthly',
                insuranceProvider: '',
                insurancePolicyNumber: '',
                insuranceCoverageAmount: '',
                insuranceBeneficiary: '',
                insurancePaymentAccountId: '',
                insurancePaymentDay: '',
                insuranceStartDate: '',
                insuranceEndDate: '',
                insuranceNote: '',
                insuranceWaitingPeriodDays: '',
                insuranceDeductible: '',
                insurancePolicyValue: '',
                insurancePremiumPaymentYears: '',
                insuranceExpectedMaturityDate: '',
                insuranceAnnuityStartDate: '',
                insuranceDistributionStartPolicyYear: '',
                insuranceAnnualDistributionAmount: '',
                insuranceDistributionMode: 'cash',
                insuranceAccumulationRate: '',
                insuranceAccumulationBalance: '',
                insuranceGuaranteedCashValue: '',
                insuranceNonGuaranteedCashValue: '',
                insuranceDistributionPaidYears: '',
                insuranceTotalDistributedAmount: '',
                insuranceProjectedRate: '',
                insuranceFundAllocation: '',
                insurancePartialWithdrawalAmount: '',
                insurancePartialWithdrawalDate: '',
                insurancePartialWithdrawalAccountId: '',
                insurancePartialWithdrawalNote: '',
                insurancePartialWithdrawalEditCashflowId: '',
                propertyPrice: '',
                ltvRatio: '',
                annualInterestRate: '',
                mortgageYears: '',
                paidPeriods: '',
                loanPrincipal: '',
                loanYears: '',
                loanPaidPeriods: '',
                loanAnnualInterestRate: '',
                creditCardBalance: '',
                creditCardMinPayment: '',
                creditCardDueDate: '',
                creditCardAnnualRate: '',
                payableAmount: '',
                payableDueDate: '',
                payableInstallments: '',
                otherOutstanding: '',
                otherAnnualRate: '',
                otherDueDate: '',
                receivableAmount: '',
                receivableDueDate: '',
                receivableInstallments: '',
                receivableParty: '',
                fixedPurchasePrice: '',
                fixedCurrentValue: '',
                fixedPurchaseDate: '',
                fixedNote: '',
                fixedDepositPrincipal: '',
                fixedDepositAnnualRate: '',
                fixedDepositMonths: '',
                fixedDepositStartDate: '',
                fixedDepositTargetLiquidAssetId: '',
                bankWealthPrincipal: '',
                bankWealthGuaranteedAnnualRate: '',
                bankWealthMaxAnnualRate: '',
                bankWealthTermDays: '',
                bankWealthStartDate: '',
                bankWealthMaturityDate: '',
                bankWealthTargetLiquidAssetId: '',
                bankWealthMaturityPayoutMode: 'guaranteed',
                bankWealthMaturityManualAmount: ''
            };
            const buildFormDataFromAsset = (asset) => {
                const INSURANCE_LIFE_WEALTH_SUBTYPES = ['定期壽險', '終身壽險', '年金險', '儲蓄險', '投資型壽險', '萬能壽險', '人壽/累積財富', '投資/投資相連'];
                const isLifeWealthSubtype = INSURANCE_LIFE_WEALTH_SUBTYPES.includes(asset?.subtype);
                const basePremiumRaw = Number(asset?.insuranceBasePremiumAmount || 0);
                const supplementaryPremiumRaw = Number(asset?.insuranceSupplementaryPremiumAmount || 0);
                const shouldBackfillBasePremium = isLifeWealthSubtype && basePremiumRaw <= 0 && supplementaryPremiumRaw <= 0;
                return {
                    ...createInitialAssetFormData(),
                    ...asset,
                    premiumFrequency: asset?.premiumFrequency ?? 'monthly',
                    insuranceBasePremiumAmount: shouldBackfillBasePremium
                        ? (asset?.premiumAmount ?? '')
                        : (asset?.insuranceBasePremiumAmount ?? ''),
                    insuranceHasSupplementaryBenefit: asset?.insuranceHasSupplementaryBenefit === 'yes' ? 'yes' : 'no',
                    insuranceSupplementaryPremiumAmount: asset?.insuranceSupplementaryPremiumAmount ?? '',
                    insuranceSupplementaryBenefitName: asset?.insuranceSupplementaryBenefitName ?? '',
                    insuranceSupplementaryBenefitRegion: asset?.insuranceSupplementaryBenefitRegion ?? '',
                    insuranceSupplementaryBenefitDeductible: asset?.insuranceSupplementaryBenefitDeductible ?? '',
                    insuranceInvestmentFundItems: asset?.insuranceInvestmentFundItems ?? '',
                    insuranceInvestmentStrategyNote: asset?.insuranceInvestmentStrategyNote ?? ''
                };
            };

            const [assets, setAssets] = useState(() => parseStorage(STORAGE_KEYS.assets, seedAssets));
            const [displayCurrency, setDisplayCurrency] = useState(() => parseStorage(STORAGE_KEYS.displayCurrency, 'HKD'));
            const [monthlySnapshots, setMonthlySnapshots] = useState(() => parseStorage(STORAGE_KEYS.monthlySnapshots, {}));
            const [cashflowEntries, setCashflowEntries] = useState(() => sanitizeCashflowEntries(parseStorage(STORAGE_KEYS.cashflowEntries, [])));
            const [cashflowAppliedOccurrenceKeys, setCashflowAppliedOccurrenceKeys] = useState(() => {
                const raw = parseStorage(STORAGE_KEYS.cashflowAppliedOccurrenceKeys, []);
                return Array.isArray(raw) ? raw.filter(item => typeof item === 'string') : [];
            });
            const [cashflowAppliedPostings, setCashflowAppliedPostings] = useState(() => {
                const raw = parseStorage(STORAGE_KEYS.cashflowAppliedPostings, {});
                if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return {};
                const next = {};
                Object.entries(raw).forEach(([key, value]) => {
                    if (!key || !value || typeof value !== 'object') return;
                    const signedAmount = Number(value.signedAmount);
                    if (!Number.isFinite(signedAmount)) return;
                    next[key] = {
                        entryId: typeof value.entryId === 'string' ? value.entryId : '',
                        targetLiquidAssetId: typeof value.targetLiquidAssetId === 'string' ? value.targetLiquidAssetId : '',
                        signedAmount,
                        targetCurrency: typeof value.targetCurrency === 'string' ? value.targetCurrency : '',
                        type: value.type === 'INCOME' ? 'INCOME' : 'EXPENSE'
                    };
                });
                return next;
            });
            const [cashflowLastAutoApplyDate, setCashflowLastAutoApplyDate] = useState(() => normalizeDateKeyOrFallback(
                parseStorage(STORAGE_KEYS.cashflowLastAutoApplyDate, ''),
                new Date(Date.now() - ONE_DAY_MS)
            ));
            const [currencyRates, setCurrencyRates] = useState(() => sanitizeCurrencyRates(parseStorage(STORAGE_KEYS.currencyRates, DEFAULT_RATES)));
            const [lastRateUpdate, setLastRateUpdate] = useState(() => {
                const saved = Number(parseStorage(STORAGE_KEYS.currencyRatesUpdatedAt, 0));
                return Number.isFinite(saved) && saved > 0 ? new Date(saved) : null;
            });
            const [authUser, setAuthUser] = useState(null);
            const [isAuthLoading, setIsAuthLoading] = useState(isCloudEnabled);
            const [isCloudSyncing, setIsCloudSyncing] = useState(false);
            const [cloudStatus, setCloudStatus] = useState('');
            const [cloudStatusMode, setCloudStatusMode] = useState('auth');
            const [cloudAuthState, setCloudAuthState] = useState(() => ({
                status: isCloudEnabled ? 'signed-out' : 'disabled',
                email: ''
            }));

            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isCashflowModalOpen, setIsCashflowModalOpen] = useState(false);
            const [editingId, setEditingId] = useState(null);
            const [selectedCategories, setSelectedCategories] = useState(CATEGORY_KEYS);
            const [sortMode, setSortMode] = useState('AMOUNT_DESC');
            const [viewMode, setViewMode] = useState('DETAIL');
            const [isUpdatingPrice, setIsUpdatingPrice] = useState(false);
            const [isUpdatingRates, setIsUpdatingRates] = useState(false);
            const [isGeneratingPdf, setIsGeneratingPdf] = useState(false);
            const [priceStatus, setPriceStatus] = useState('');
            const [lastPriceUpdate, setLastPriceUpdate] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [pageLanguage, setPageLanguage] = useState(() => {
                const saved = parseStorage(STORAGE_KEYS.pageLanguage, 'zh-Hant');
                return PAGE_LANGUAGE_OPTIONS.some(item => item.value === saved) ? saved : 'zh-Hant';
            });
            const themeIds = Object.keys(THEMES || {});
            const [themeId, setThemeId] = useState(() => {
                const saved = parseStorage(STORAGE_KEYS.themeId, 'macaron-prince');
                return themeIds.includes(saved) ? saved : 'macaron-prince';
            });
            const [headerSloganIndex, setHeaderSloganIndex] = useState(0);
            const [princeIdleIndex, setPrinceIdleIndex] = useState(0);
            const [selectedMixCategory, setSelectedMixCategory] = useState('INVEST');
            const [expandedAccounts, setExpandedAccounts] = useState({});
            const [selectedStatsCategory, setSelectedStatsCategory] = useState('INVEST');
            const [selectedStatsAccount, setSelectedStatsAccount] = useState('');
            const [selectedStatsSegmentKey, setSelectedStatsSegmentKey] = useState('');
            const [statsBreakdownMode, setStatsBreakdownMode] = useState('ACCOUNT');
            const [financeSectionTab, setFinanceSectionTab] = useState('ASSET_ACCOUNT');
            const [cashflowView, setCashflowView] = useState('MONTH');
            const [selectedCashflowMonth, setSelectedCashflowMonth] = useState(() => toMonthKey(new Date()));
            const [editingCashflowId, setEditingCashflowId] = useState('');
            const [cashflowRuleKeyword, setCashflowRuleKeyword] = useState('');
            const [cashflowRuleFilter, setCashflowRuleFilter] = useState('ALL');
            const [cashflowRuleSortMode, setCashflowRuleSortMode] = useState('START_DESC');
            const [cashflowRulesVisibleCount, setCashflowRulesVisibleCount] = useState(20);
            const createInitialCashflowForm = () => {
                const today = toDateKey(new Date());
                return {
                    title: '',
                    account: '',
                    category: getDefaultCashflowCategory('INCOME'),
                    type: 'INCOME',
                    scheduleType: 'RECURRING',
                    amount: '',
                    currency: 'HKD',
                    frequency: 'MONTHLY',
                    startDate: today,
                    oneTimeDates: [],
                    endDate: '',
                    payday: '25',
                    targetLiquidAssetId: '',
                    note: ''
                };
            };
            const [cashflowForm, setCashflowForm] = useState(() => createInitialCashflowForm());
            const updateCashflowField = (field) => (event) => {
                const value = event.target.value;
                if (field === 'currency') markRecentCurrency(value);
                setCashflowForm(prev => ({ ...prev, [field]: value }));
            };
            const normalizeOneTimeDateList = (rawList) => {
                const unique = new Set();
                (Array.isArray(rawList) ? rawList : []).forEach(item => {
                    const raw = typeof item === 'string' ? item : '';
                    const parsed = parseDateKey(raw);
                    if (!parsed) return;
                    unique.add(toDateKey(parsed));
                });
                return Array.from(unique).sort();
            };
            const toggleCashflowOneTimeDate = (dateKey) => {
                setCashflowForm(prev => {
                    const hasDate = (prev.oneTimeDates || []).includes(dateKey);
                    const normalized = hasDate
                        ? normalizeOneTimeDateList((prev.oneTimeDates || []).filter(item => item !== dateKey))
                        : normalizeOneTimeDateList([...(prev.oneTimeDates || []), dateKey]);
                    return {
                        ...prev,
                        startDate: dateKey,
                        oneTimeDates: normalized
                    };
                });
            };
            const updateCashflowOneTimeMonth = (monthKey) => {
                const match = /^(\d{4})-(\d{2})$/.exec(monthKey || '');
                if (!match) return;
                const year = Number(match[1]);
                const month = Number(match[2]);
                if (!Number.isInteger(year) || !Number.isInteger(month) || month < 1 || month > 12) return;

                setCashflowForm(prev => {
                    const parsedStart = parseDateKey(prev.startDate) || new Date();
                    const currentDay = parsedStart.getDate();
                    const daysInMonth = new Date(year, month, 0).getDate();
                    const nextDay = Math.min(currentDay, daysInMonth);
                    const nextDate = toDateKey(new Date(year, month - 1, nextDay));
                    return {
                        ...prev,
                        startDate: nextDate
                    };
                });
            };
            const applyCashflowOneTimeMonthPreset = (mode, monthKey, weekdayIndexes = []) => {
                const match = /^(\d{4})-(\d{2})$/.exec(monthKey || '');
                if (!match) return;

                const year = Number(match[1]);
                const month = Number(match[2]);
                if (!Number.isInteger(year) || !Number.isInteger(month) || month < 1 || month > 12) return;

                const daysInMonth = new Date(year, month, 0).getDate();
                const generated = [];
                const customWeekdaySet = new Set(
                    (Array.isArray(weekdayIndexes) ? weekdayIndexes : [])
                        .map(value => Number(value))
                        .filter(value => Number.isInteger(value) && value >= 0 && value <= 6)
                );
                for (let day = 1; day <= daysInMonth; day += 1) {
                    const current = new Date(year, month - 1, day);
                    const weekday = current.getDay();
                    if (mode === 'WEEKDAYS' && (weekday === 0 || weekday === 6)) continue;
                    if (mode === 'WEEKENDS' && weekday !== 0 && weekday !== 6) continue;
                    if (mode === 'CUSTOM_WEEKDAYS' && !customWeekdaySet.has(weekday)) continue;
                    generated.push(toDateKey(current));
                }

                setCashflowForm(prev => {
                    const monthPrefix = `${monthKey}-`;
                    const remaining = (prev.oneTimeDates || []).filter(dateKey => !String(dateKey).startsWith(monthPrefix));
                    const normalized = normalizeOneTimeDateList([...remaining, ...generated]);
                    const fallbackStartDate = generated[0] || prev.startDate;
                    return {
                        ...prev,
                        startDate: fallbackStartDate,
                        oneTimeDates: normalized
                    };
                });
            };
            const clearCashflowOneTimeDates = () => {
                setCashflowForm(prev => ({
                    ...prev,
                    oneTimeDates: []
                }));
            };
            const updateCashflowType = (event) => {
                const nextType = event.target.value;
                setCashflowForm(prev => ({
                    ...prev,
                    type: nextType,
                    category: getDefaultCashflowCategory(nextType)
                }));
            };
            const updateCashflowTargetLiquidAsset = (event) => {
                const nextId = event.target.value;
                const selected = liquidAssetOptions.find(option => option.id === nextId) || null;
                setCashflowForm(prev => ({
                    ...prev,
                    targetLiquidAssetId: nextId,
                    account: selected?.account || prev.account
                }));
            };

            const [formData, setFormData] = useState(() => createInitialAssetFormData());
            const importInputRef = useRef(null);
            const cashflowFormRef = useRef(null);

            const themeTokensById = useMemo(() => {
                const themeMap = window.APP_THEME_SYSTEM?.THEMES || {};
                const fallbackTokens = themeMap['macaron-prince']?.tokens || {};
                const selectedTokens = themeMap[themeId]?.tokens || fallbackTokens;
                return { ...fallbackTokens, ...selectedTokens };
            }, [themeId]);

            const getThemeTokenByTheme = (tokenName, fallback) => {
                const value = themeTokensById[tokenName];
                return value || fallback;
            };

            const getThemeToken = (tokenName, fallback) => {
                if (typeof window === 'undefined' || typeof document === 'undefined') return fallback;
                const value = getComputedStyle(document.documentElement).getPropertyValue(tokenName).trim();
                return value || fallback;
            };

            const chartThemePalette = useMemo(() => {
                return [
                    getThemeTokenByTheme('--primary', '#F472B6'),
                    getThemeTokenByTheme('--accent', '#38BDF8'),
                    getThemeTokenByTheme('--gold', '#F59E0B'),
                    getThemeTokenByTheme('--card-net-mid', '#A78BFA'),
                    getThemeTokenByTheme('--card-net-end', '#818CF8'),
                    getThemeTokenByTheme('--danger', '#F43F5E'),
                    getThemeTokenByTheme('--header-border', '#22D3EE'),
                    getThemeTokenByTheme('--panel-soft', '#FB7185')
                ];
            }, [themeTokensById]);

            const exportThemeTokens = useMemo(() => ({
                '--bg-page': getThemeTokenByTheme('--bg-page', '#ffffff'),
                '--text-main': getThemeTokenByTheme('--text-main', '#0f172a'),
                '--text-sub': getThemeTokenByTheme('--text-sub', '#475569'),
                '--panel-bg': getThemeTokenByTheme('--panel-bg', '#ffffff'),
                '--panel-soft': getThemeTokenByTheme('--panel-soft', '#f8fafc'),
                '--header-border': getThemeTokenByTheme('--header-border', '#cbd5e1'),
                '--primary': getThemeTokenByTheme('--primary', '#F472B6'),
                '--accent': getThemeTokenByTheme('--accent', '#38BDF8'),
                '--gold': getThemeTokenByTheme('--gold', '#F59E0B'),
                '--danger': getThemeTokenByTheme('--danger', '#F43F5E')
            }), [themeTokensById]);

            const categoryMixHexByKey = useMemo(() => getCategoryMixHexByTheme(themeId), [themeId]);

            const detailMixPalette = useMemo(() => getDetailMixPaletteByTheme(themeId), [themeId]);


            const handleAssetCategoryChange = (event) => {
                const nextCategory = event.target.value;
                setFormData(prev => ({
                    ...prev,
                    category: nextCategory,
                    subtype: CATEGORIES[nextCategory].subtypes[0],
                    ...ASSET_FORM_DETAIL_RESET_FIELDS
                }));
            };

            const handleAssetSubtypeChange = (event) => {
                const nextSubtype = event.target.value;
                setFormData(prev => ({
                    ...prev,
                    subtype: nextSubtype,
                    ...ASSET_FORM_DETAIL_RESET_FIELDS
                }));
            };

            const isLiquidForm = formData.category === 'LIQUID';
            const isInvestForm = formData.category === 'INVEST';
            const isCryptoForm = isInvestForm && formData.subtype === '加密貨幣';
            const isStockForm = isInvestForm && formData.subtype === '股票';
            const isFundForm = isInvestForm && formData.subtype === '基金';
            const isFixedDepositForm = isInvestForm && formData.subtype === '定期存款';
            const isBankWealthForm = isInvestForm && formData.subtype === '銀行理財';
            const isInsuranceForm = formData.category === 'INSURANCE';
            const isLiabilityForm = formData.category === 'LIABILITY';
            const isReceivableForm = formData.category === 'RECEIVABLE';
            const isFixedForm = formData.category === 'FIXED';
            const isMortgageForm = isLiabilityForm && formData.subtype === '房貸';
            const isLoanForm = isLiabilityForm && formData.subtype === '貸款';
            const isCreditCardForm = isLiabilityForm && formData.subtype === '信用卡';
            const isPayableForm = isLiabilityForm && formData.subtype === '應付款';
            const isOtherLiabilityForm = isLiabilityForm && formData.subtype === '其他負債';
            const isHealthInsuranceForm = isInsuranceForm && INSURANCE_SUBTYPE_GROUPS.HEALTH.includes(formData.subtype);
            const isLifeWealthInsuranceForm = isInsuranceForm && INSURANCE_SUBTYPE_GROUPS.LIFE_WEALTH.includes(formData.subtype);
            const needsPremium = isInsuranceForm && (isHealthInsuranceForm || isLifeWealthInsuranceForm);
            const premiumTotal = (Number(formData.premiumAmount) || 0) * (Number(formData.premiumPaidCount) || 0);
            const mortgageMetrics = isMortgageForm ? calculateMortgageMetrics(formData) : null;
            const loanMetrics = isLoanForm ? calculateInstallmentLoanMetrics({
                loanPrincipal: formData.loanPrincipal,
                annualInterestRate: formData.loanAnnualInterestRate,
                loanYears: formData.loanYears,
                paidPeriods: formData.loanPaidPeriods
            }) : null;
            const fixedDepositMetrics = isFixedDepositForm ? calculateFixedDepositMetrics({
                principal: formData.fixedDepositPrincipal,
                annualInterestRate: formData.fixedDepositAnnualRate,
                months: formData.fixedDepositMonths
            }) : null;
            const bankWealthMetrics = isBankWealthForm ? calculateBankWealthMetrics({
                principal: formData.bankWealthPrincipal,
                guaranteedAnnualRate: formData.bankWealthGuaranteedAnnualRate,
                maxAnnualRate: formData.bankWealthMaxAnnualRate,
                termDays: formData.bankWealthTermDays
            }) : null;

            const assetsRef = useRef(assets);
            useEffect(() => { assetsRef.current = assets; }, [assets]);

            const toHKD = (amount, currency) => amount / (currencyRates[currency] || 1);
            const fromHKD = (amountHKD, currency) => amountHKD * (currencyRates[currency] || 1);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.assets, JSON.stringify(assets));
            }, [assets]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.displayCurrency, JSON.stringify(displayCurrency));
            }, [displayCurrency]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.recentCurrencies, JSON.stringify(sanitizeRecentCurrencies(recentCurrencies)));
            }, [recentCurrencies]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.currencyRates, JSON.stringify(currencyRates));
            }, [currencyRates]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.cashflowEntries, JSON.stringify(cashflowEntries));
            }, [cashflowEntries]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.cashflowAppliedOccurrenceKeys, JSON.stringify(cashflowAppliedOccurrenceKeys));
            }, [cashflowAppliedOccurrenceKeys]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.cashflowAppliedPostings, JSON.stringify(cashflowAppliedPostings));
            }, [cashflowAppliedPostings]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.cashflowLastAutoApplyDate, JSON.stringify(cashflowLastAutoApplyDate));
            }, [cashflowLastAutoApplyDate]);

            useEffect(() => {
                const stamp = lastRateUpdate instanceof Date ? lastRateUpdate.getTime() : 0;
                localStorage.setItem(STORAGE_KEYS.currencyRatesUpdatedAt, JSON.stringify(stamp));
            }, [lastRateUpdate]);

            useEffect(() => {
                localStorage.setItem(STORAGE_KEYS.pageLanguage, JSON.stringify(pageLanguage));
            }, [pageLanguage]);

            useEffect(() => {
                const appliedThemeId = applyTheme(themeId);
                if (appliedThemeId !== themeId) {
                    setThemeId(appliedThemeId);
                    return;
                }
                localStorage.setItem(STORAGE_KEYS.themeId, JSON.stringify(appliedThemeId));
            }, [themeId]);

            useEffect(() => {
                if (!isModalOpen) return;

                const body = document.body;
                const html = document.documentElement;
                const scrollY = window.scrollY || window.pageYOffset || 0;

                const prevBodyOverflow = body.style.overflow;
                const prevBodyPosition = body.style.position;
                const prevBodyTop = body.style.top;
                const prevBodyLeft = body.style.left;
                const prevBodyRight = body.style.right;
                const prevBodyWidth = body.style.width;
                const prevHtmlOverflow = html.style.overflow;

                body.style.overflow = 'hidden';
                body.style.position = 'fixed';
                body.style.top = `-${scrollY}px`;
                body.style.left = '0';
                body.style.right = '0';
                body.style.width = '100%';
                html.style.overflow = 'hidden';

                return () => {
                    body.style.overflow = prevBodyOverflow;
                    body.style.position = prevBodyPosition;
                    body.style.top = prevBodyTop;
                    body.style.left = prevBodyLeft;
                    body.style.right = prevBodyRight;
                    body.style.width = prevBodyWidth;
                    html.style.overflow = prevHtmlOverflow;
                    window.scrollTo(0, scrollY);
                };
            }, [isModalOpen]);

            useEffect(() => {
                if (window.lucide) window.lucide.createIcons();
            }, [assets, isModalOpen, isCashflowModalOpen, selectedCategories, sortMode, isUpdatingPrice]);

            const pageText = useMemo(() => UI_TEXT[pageLanguage] || UI_TEXT['zh-Hant'], [pageLanguage]);
            const tByLang = (zh, en, ja) => (pageLanguage === 'en-US' ? en : (pageLanguage === 'ja-JP' ? ja : zh));
            const tByLangBy = (lang, zh, en, ja) => (lang === 'en-US' ? en : (lang === 'ja-JP' ? ja : zh));
            const dictionary = useMemo(() => FULL_PAGE_TEXT_MAP[pageLanguage] || {}, [pageLanguage]);
            const translate = (text) => (pageLanguage === 'zh-Hant' ? text : (dictionary[text] || text));
            const themeNameMap = useMemo(() => THEME_NAME_MAP[pageLanguage] || THEME_NAME_MAP['zh-Hant'] || {}, [pageLanguage]);
            const themeOptions = useMemo(() => {
                return Object.values(THEMES || {}).map(theme => ({
                    value: theme.id,
                    label: themeNameMap[theme.id] || theme.label || theme.id
                }));
            }, [themeNameMap, THEMES]);
            const cloudStatusBuilderRef = useRef(null);
            const setCloudStatusWithMode = (messageOrBuilder, mode = 'action') => {
                if (typeof messageOrBuilder === 'function') {
                    cloudStatusBuilderRef.current = messageOrBuilder;
                    setCloudStatus(messageOrBuilder(pageLanguage));
                } else {
                    cloudStatusBuilderRef.current = null;
                    setCloudStatus(messageOrBuilder);
                }
                setCloudStatusMode(mode);
            };
            const buildCloudAuthStatusMessage = (state) => getCloudAuthStatusMessage(pageLanguage, state);

            useEffect(() => {
                if (cloudStatusMode !== 'auth') return;
                setCloudStatus(buildCloudAuthStatusMessage(cloudAuthState));
            }, [cloudAuthState, cloudStatusMode, pageLanguage]);

            useEffect(() => {
                if (cloudStatusMode !== 'action') return;
                const builder = cloudStatusBuilderRef.current;
                if (typeof builder !== 'function') return;
                setCloudStatus(builder(pageLanguage));
            }, [cloudStatusMode, pageLanguage]);
            const appName = useMemo(() => {
                if (pageLanguage === 'zh-Hant') return '王子甜甜帳';
                if (pageLanguage === 'ja-JP') return '王子あま帳';
                return 'SweetPrinceLedger';
            }, [pageLanguage]);
            const dateTimeLocale = useMemo(() => {
                if (pageLanguage === 'ja-JP') return 'ja-JP';
                if (pageLanguage === 'en-US') return 'en-US';
                return 'zh-Hant-TW';
            }, [pageLanguage]);
            const formatDateTime = (dateValue) => {
                const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
                if (Number.isNaN(date.getTime())) return '';
                return date.toLocaleString(dateTimeLocale);
            };
            const headerSlogans = useMemo(() => HEADER_SLOGANS[pageLanguage] || HEADER_SLOGANS['zh-Hant'], [pageLanguage]);
            const idleHintLines = useMemo(() => IDLE_HINT_LINES[pageLanguage] || IDLE_HINT_LINES['zh-Hant'], [pageLanguage]);
            const currentHeaderSlogan = headerSlogans[headerSloganIndex % Math.max(headerSlogans.length, 1)] || '';
            const currentIdleHint = idleHintLines[princeIdleIndex % Math.max(idleHintLines.length, 1)] || '';

            useEffect(() => {
                document.documentElement.lang = pageLanguage;
            }, [pageLanguage]);

            useEffect(() => {
                document.title = appName;
            }, [appName]);

            useEffect(() => {
                if (pageLanguage === 'zh-Hant') return;
                const root = document.getElementById('root');
                if (!root) return;

                const dictionary = FULL_PAGE_TEXT_MAP[pageLanguage] || {};
                if (!Object.keys(dictionary).length) return;

                let applying = false;
                const applyFullPageTranslation = () => {
                    if (applying) return;
                    applying = true;

                    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
                    const textNodes = [];
                    let current = walker.nextNode();
                    while (current) {
                        textNodes.push(current);
                        current = walker.nextNode();
                    }

                    textNodes.forEach(node => {
                        if (!node || !node.nodeValue) return;
                        const original = node.nodeValue;
                        const trimmed = original.trim();
                        if (!trimmed) return;
                        const translated = dictionary[trimmed];
                        if (!translated || translated === trimmed) return;
                        const leading = original.match(/^\s*/)?.[0] || '';
                        const trailing = original.match(/\s*$/)?.[0] || '';
                        node.nodeValue = `${leading}${translated}${trailing}`;
                    });

                    root.querySelectorAll('[placeholder]').forEach(el => {
                        const val = el.getAttribute('placeholder') || '';
                        const translated = dictionary[val.trim()];
                        if (translated) el.setAttribute('placeholder', translated);
                    });

                    root.querySelectorAll('[title]').forEach(el => {
                        const val = el.getAttribute('title') || '';
                        const translated = dictionary[val.trim()];
                        if (translated) el.setAttribute('title', translated);
                    });

                    root.querySelectorAll('[aria-label]').forEach(el => {
                        const val = el.getAttribute('aria-label') || '';
                        const translated = dictionary[val.trim()];
                        if (translated) el.setAttribute('aria-label', translated);
                    });

                    applying = false;
                };

                applyFullPageTranslation();
                const observer = new MutationObserver(() => applyFullPageTranslation());
                observer.observe(root, { childList: true, subtree: true, characterData: true, attributes: true, attributeFilter: ['placeholder', 'title', 'aria-label'] });
                return () => observer.disconnect();
            }, [pageLanguage, assets, cashflowEntries, financeSectionTab, isModalOpen, isCashflowModalOpen, editingId, editingCashflowId, showSettings]);

            useEffect(() => {
                setHeaderSloganIndex(0);
                setPrinceIdleIndex(0);
            }, [pageLanguage]);

            useEffect(() => {
                const timer = setInterval(() => {
                    setHeaderSloganIndex(prev => (prev + 1) % Math.max(headerSlogans.length, 1));
                }, 5000);
                return () => clearInterval(timer);
            }, [headerSlogans]);

            useEffect(() => {
                const timer = setInterval(() => {
                    setPrinceIdleIndex(prev => (prev + 1) % Math.max(idleHintLines.length, 1));
                }, 8000);
                return () => clearInterval(timer);
            }, [idleHintLines]);

            const princeHintMessage = useMemo(() => {
                return getPrinceHintMessage({
                    pageLanguage,
                    isGeneratingPdf,
                    isUpdatingPrice,
                    isUpdatingRates,
                    isCloudSyncing,
                    isModalOpen,
                    isCashflowModalOpen,
                    editingCashflowId,
                    showSettings,
                    financeSectionTab,
                    priceStatus,
                    currentIdleHint
                });
            }, [isGeneratingPdf, isUpdatingPrice, isUpdatingRates, isCloudSyncing, isModalOpen, isCashflowModalOpen, editingCashflowId, showSettings, financeSectionTab, priceStatus, currentIdleHint, pageLanguage]);

            const totals = useMemo(() => {
                let assetsHKD = 0;
                let liabilitiesHKD = 0;
                const categoryBreakdownHKD = {};
                const investSubtypeHKD = {};

                assets.forEach(asset => {
                    const marketValueHKD = toHKD(asset.quantity * asset.currentPrice, asset.currency);
                    categoryBreakdownHKD[asset.category] = (categoryBreakdownHKD[asset.category] || 0) + marketValueHKD;
                    if (asset.category === 'INVEST') {
                        investSubtypeHKD[asset.subtype] = (investSubtypeHKD[asset.subtype] || 0) + marketValueHKD;
                    }
                    if (CATEGORIES[asset.category].isNegative) liabilitiesHKD += marketValueHKD;
                    else assetsHKD += marketValueHKD;
                });

                const investTotalHKD = Object.values(investSubtypeHKD).reduce((sum, value) => sum + value, 0);
                const debtRatio = assetsHKD > 0 ? (liabilitiesHKD / assetsHKD) * 100 : 0;

                return {
                    assetsHKD,
                    liabilitiesHKD,
                    netWorthHKD: assetsHKD - liabilitiesHKD,
                    debtRatio,
                    investTotalHKD,
                    categoryBreakdownHKD,
                    investSubtypeHKD,
                    assets: fromHKD(assetsHKD, displayCurrency),
                    liabilities: fromHKD(liabilitiesHKD, displayCurrency),
                    netWorth: fromHKD(assetsHKD - liabilitiesHKD, displayCurrency)
                };
            }, [assets, displayCurrency, currencyRates]);

            useEffect(() => {
                const monthKey = new Date().toISOString().slice(0, 7);
                setMonthlySnapshots(prev => {
                    const current = prev[monthKey];
                    const nextSnapshot = {
                        assetsHKD: Number(totals.assetsHKD.toFixed(2)),
                        liabilitiesHKD: Number(totals.liabilitiesHKD.toFixed(2)),
                        netWorthHKD: Number(totals.netWorthHKD.toFixed(2)),
                        debtRatio: Number(totals.debtRatio.toFixed(2)),
                        updatedAt: Date.now()
                    };
                    if (
                        current &&
                        current.assetsHKD === nextSnapshot.assetsHKD &&
                        current.liabilitiesHKD === nextSnapshot.liabilitiesHKD &&
                        current.netWorthHKD === nextSnapshot.netWorthHKD &&
                        current.debtRatio === nextSnapshot.debtRatio
                    ) {
                        return prev;
                    }
                    const next = { ...prev, [monthKey]: nextSnapshot };
                    localStorage.setItem(STORAGE_KEYS.monthlySnapshots, JSON.stringify(next));
                    return next;
                });
            }, [totals.assetsHKD, totals.liabilitiesHKD, totals.netWorthHKD, totals.debtRatio]);

            const groupedAssets = useMemo(() => {
                const groups = {};
                assets.forEach(asset => {
                    if (!selectedCategories.includes(asset.category)) return;
                    if (!groups[asset.category]) groups[asset.category] = {};
                    if (!groups[asset.category][asset.account]) groups[asset.category][asset.account] = [];
                    groups[asset.category][asset.account].push(asset);
                });

                const compareByName = (a, b) => a.localeCompare(b, 'zh-Hant', { numeric: true, sensitivity: 'base' });

                return CATEGORY_KEYS
                    .filter(categoryKey => groups[categoryKey])
                    .map(categoryKey => {
                        const accountMap = groups[categoryKey];
                        const accounts = Object.entries(accountMap).map(([accountName, items]) => {
                            const sortedItems = [...items].sort((a, b) => {
                                if (sortMode === 'NAME_ASC') {
                                    return compareByName(a.name || '', b.name || '');
                                }
                                const aValue = Math.abs(toHKD(a.quantity * a.currentPrice, a.currency));
                                const bValue = Math.abs(toHKD(b.quantity * b.currentPrice, b.currency));
                                return bValue - aValue;
                            });

                            const accountTotalHKD = sortedItems.reduce((sum, item) => {
                                return sum + Math.abs(toHKD(item.quantity * item.currentPrice, item.currency));
                            }, 0);

                            return {
                                accountName,
                                items: sortedItems,
                                accountTotalHKD
                            };
                        });

                        const sortedAccounts = [...accounts].sort((a, b) => {
                            if (sortMode === 'NAME_ASC') {
                                return compareByName(a.accountName, b.accountName);
                            }
                            return b.accountTotalHKD - a.accountTotalHKD;
                        });

                        return {
                            categoryKey,
                            accounts: sortedAccounts
                        };
                    });
            }, [assets, selectedCategories, sortMode, currencyRates]);

            const toggleCategory = (categoryKey) => {
                setSelectedCategories(prev => {
                    if (prev.includes(categoryKey)) {
                        if (prev.length === 1) return prev;
                        return prev.filter(key => key !== categoryKey);
                    }
                    return [...prev, categoryKey];
                });
            };

            useEffect(() => {
                const keys = [];
                groupedAssets.forEach(group => {
                    group.accounts.forEach(account => {
                        keys.push(`${group.categoryKey}::${account.accountName}`);
                    });
                });

                setExpandedAccounts(prev => {
                    const next = { ...prev };
                    keys.forEach(key => {
                        if (typeof next[key] === 'undefined') next[key] = true;
                    });
                    return next;
                });
            }, [groupedAssets]);

            const toggleAccountExpand = (categoryKey, accountName) => {
                const key = `${categoryKey}::${accountName}`;
                setExpandedAccounts(prev => ({
                    ...prev,
                    [key]: !(prev[key] ?? true)
                }));
            };

            const assetMix = useMemo(() => {
                const rows = Object.keys(CATEGORIES).map(categoryKey => {
                    const valueHKD = Math.abs(totals.categoryBreakdownHKD[categoryKey] || 0);
                    return {
                        categoryKey,
                        label: translate(CATEGORIES[categoryKey].label),
                        valueHKD,
                        amount: fromHKD(valueHKD, displayCurrency),
                        hex: categoryMixHexByKey[categoryKey] || getThemeToken('--primary', '#8B5CF6')
                    };
                });

                const totalMixHKD = rows.reduce((sum, row) => sum + row.valueHKD, 0);
                const rowsWithRatio = rows.map(row => ({
                    ...row,
                    ratio: totalMixHKD > 0 ? (row.valueHKD / totalMixHKD) * 100 : 0
                })).sort((a, b) => b.valueHKD - a.valueHKD);

                let cumulative = 0;
                const segments = rowsWithRatio
                    .filter(row => row.ratio > 0)
                    .map(row => {
                        const start = cumulative;
                        cumulative += row.ratio;
                        return `${row.hex} ${start}% ${cumulative}%`;
                    });

                const emptyColor = getThemeToken('--panel-soft', '#FCE7F3');

                return {
                    rows: rowsWithRatio,
                    gradient: segments.length ? `conic-gradient(${segments.join(', ')})` : `conic-gradient(${emptyColor} 0% 100%)`
                };
            }, [totals.categoryBreakdownHKD, displayCurrency, categoryMixHexByKey, pageLanguage, dictionary]);

            useEffect(() => {
                const selectedExists = assetMix.rows.some(row => row.categoryKey === selectedMixCategory);
                if (!selectedExists) {
                    const first = assetMix.rows[0]?.categoryKey || 'INVEST';
                    setSelectedMixCategory(first);
                }
            }, [assetMix.rows, selectedMixCategory]);

            const detailMix = useMemo(() => {
                const category = selectedMixCategory;
                const categoryAssets = assets.filter(item => item.category === category);
                const groupMap = {};

                categoryAssets.forEach(item => {
                    const key = category === 'LIQUID'
                        ? (item.currency || 'N/A')
                        : (item.subtype || '其他');
                    const amountHKD = Math.abs(toHKD(item.quantity * item.currentPrice, item.currency));
                    groupMap[key] = (groupMap[key] || 0) + amountHKD;
                });

                const totalHKD = Object.values(groupMap).reduce((sum, value) => sum + value, 0);
                const palette = detailMixPalette;

                const sortedEntries = Object.entries(groupMap)
                    .sort((a, b) => {
                        const valueDiff = b[1] - a[1];
                        if (Math.abs(valueDiff) > 0.000001) return valueDiff;
                        return String(a[0]).localeCompare(String(b[0]), 'zh-Hant', { sensitivity: 'base', numeric: true });
                    });

                const rows = sortedEntries.map(([label, valueHKD], idx) => ({
                    label: translate(label),
                    valueHKD,
                    amount: fromHKD(valueHKD, displayCurrency),
                    ratio: totalHKD > 0 ? (valueHKD / totalHKD) * 100 : 0,
                    color: palette[idx % palette.length]
                }));

                let cumulative = 0;
                const segments = rows
                    .filter(row => row.ratio > 0)
                    .map(row => {
                        const start = cumulative;
                        cumulative += row.ratio;
                        return `${row.color} ${start}% ${cumulative}%`;
                    });

                const emptyColor = getThemeToken('--panel-soft', '#FCE7F3');

                return {
                    categoryLabel: translate(CATEGORIES[category]?.label || '細項'),
                    rows,
                    gradient: segments.length ? `conic-gradient(${segments.join(', ')})` : `conic-gradient(${emptyColor} 0% 100%)`
                };
            }, [assets, selectedMixCategory, displayCurrency, currencyRates, detailMixPalette, pageLanguage, dictionary]);

            const accountStats = useMemo(() => {
                const category = selectedStatsCategory;
                const categoryAssets = assets.filter(item => item.category === category);
                const categoryPalette = detailMixPalette;

                const accountMap = {};
                categoryAssets.forEach(item => {
                    if (!accountMap[item.account]) accountMap[item.account] = [];
                    accountMap[item.account].push(item);
                });

                const accountNames = Object.keys(accountMap).sort((a, b) => a.localeCompare(b, 'zh-Hant'));
                const currentAccount = accountNames.includes(selectedStatsAccount) ? selectedStatsAccount : (accountNames[0] || '');
                const selectedAssets = statsBreakdownMode === 'ITEM' ? (accountMap[currentAccount] || []) : categoryAssets;

                const grouped = {};
                if (statsBreakdownMode === 'ACCOUNT') {
                    accountNames.forEach(accountName => {
                        const accountItems = accountMap[accountName] || [];
                        const valueDisplay = accountItems.reduce((sum, item) => {
                            return sum + fromHKD(toHKD(item.quantity * item.currentPrice, item.currency), displayCurrency);
                        }, 0);
                        grouped[`ACC:${accountName}`] = {
                            key: `ACC:${accountName}`,
                            label: accountName,
                            subtype: translate(CATEGORIES[category].label),
                            symbol: '',
                            quantity: accountItems.length,
                            valueDisplay,
                            members: accountItems
                        };
                    });
                } else {
                    selectedAssets.forEach(item => {
                        const key = category === 'LIQUID'
                            ? `CUR:${item.currency}`
                            : `ASSET:${item.id}`;

                        if (!grouped[key]) {
                            grouped[key] = {
                                key,
                                label: category === 'LIQUID' ? item.currency : item.name,
                                subtype: item.subtype,
                                symbol: item.symbol,
                                quantity: 0,
                                valueDisplay: 0,
                                members: []
                            };
                        }

                        grouped[key].quantity += Number(item.quantity || 0);
                        grouped[key].valueDisplay += fromHKD(toHKD(item.quantity * item.currentPrice, item.currency), displayCurrency);
                        grouped[key].members.push(item);
                    });
                }

                const sortedItems = Object.values(grouped)
                    .sort((a, b) => {
                        const valueDiff = b.valueDisplay - a.valueDisplay;
                        if (Math.abs(valueDiff) > 0.000001) return valueDiff;
                        return String(a.label || '').localeCompare(String(b.label || ''), 'zh-Hant', { sensitivity: 'base', numeric: true });
                    });

                const items = sortedItems.map((entry, index) => ({
                    ...entry,
                    color: categoryPalette[index % categoryPalette.length]
                }));

                const total = items.reduce((sum, item) => sum + item.valueDisplay, 0);
                const itemsWithRatio = items.map(item => ({
                    ...item,
                    ratio: total > 0 ? (item.valueDisplay / total) * 100 : 0
                }));

                let currentAngle = 0;
                const segments = itemsWithRatio.map(item => {
                    const segmentAngle = (item.ratio / 100) * 360;
                    const startAngle = currentAngle;
                    const endAngle = currentAngle + segmentAngle;
                    currentAngle = endAngle;
                    return {
                        ...item,
                        startAngle,
                        endAngle
                    };
                });

                const selectedItem = segments.find(item => item.key === selectedStatsSegmentKey) || segments[0] || null;

                return {
                    category,
                    accountNames,
                    currentAccount,
                    total,
                    segments,
                    selectedItem,
                    mode: statsBreakdownMode
                };
            }, [assets, displayCurrency, selectedStatsCategory, selectedStatsAccount, selectedStatsSegmentKey, statsBreakdownMode, currencyRates, detailMixPalette, pageLanguage, dictionary]);

            const liquidAssetOptions = useMemo(() => {
                return assets
                    .filter(item => item.category === 'LIQUID')
                    .map(item => ({
                        id: item.id,
                        account: item.account,
                        name: item.name,
                        currency: item.currency,
                        label: `${item.account}｜${item.name}（${item.currency}）`
                    }))
                    .sort((a, b) => a.label.localeCompare(b.label, 'zh-Hant', { sensitivity: 'base' }));
            }, [assets]);

            const liquidAssetLabelById = useMemo(() => {
                const map = {};
                liquidAssetOptions.forEach(option => {
                    map[option.id] = option.label;
                });
                return map;
            }, [liquidAssetOptions]);

            const cashflowRulesByLiquidAssetId = useMemo(() => {
                const grouped = {};
                cashflowEntries.forEach(entry => {
                    if (!entry.targetLiquidAssetId) return;
                    if (!grouped[entry.targetLiquidAssetId]) grouped[entry.targetLiquidAssetId] = [];
                    grouped[entry.targetLiquidAssetId].push(entry);
                });
                Object.keys(grouped).forEach(key => {
                    grouped[key].sort((a, b) => a.title.localeCompare(b.title, 'zh-Hant', { sensitivity: 'base' }));
                });
                return grouped;
            }, [cashflowEntries]);

            const cashflowAutoRulesByLiquidAssetId = useMemo(() => {
                const grouped = {};
                cashflowEntries.forEach(entry => {
                    if (!entry.targetLiquidAssetId) return;
                    if (entry.scheduleType === 'ONE_TIME') return;
                    if (!grouped[entry.targetLiquidAssetId]) grouped[entry.targetLiquidAssetId] = [];
                    grouped[entry.targetLiquidAssetId].push(entry);
                });
                Object.keys(grouped).forEach(key => {
                    grouped[key].sort((a, b) => a.title.localeCompare(b.title, 'zh-Hant', { sensitivity: 'base' }));
                });
                return grouped;
            }, [cashflowEntries]);

            const insuranceAutoPaidCountByAssetId = useMemo(() => {
                const postingCountByEntryId = {};
                Object.values(cashflowAppliedPostings).forEach(posting => {
                    if (!posting || typeof posting !== 'object') return;
                    const entryId = typeof posting.entryId === 'string' ? posting.entryId : '';
                    if (!entryId) return;
                    postingCountByEntryId[entryId] = (postingCountByEntryId[entryId] || 0) + 1;
                });

                const countByAssetId = {};
                cashflowEntries.forEach(entry => {
                    if (entry.linkedSource !== 'INSURANCE_AUTO') return;
                    if (!entry.linkedAssetId) return;
                    const appliedCount = postingCountByEntryId[entry.id] || 0;
                    countByAssetId[entry.linkedAssetId] = (countByAssetId[entry.linkedAssetId] || 0) + appliedCount;
                });
                return countByAssetId;
            }, [cashflowEntries, cashflowAppliedPostings]);

            const insurancePartialWithdrawalStatsByAssetId = useMemo(() => {
                const statsByAssetId = {};
                cashflowEntries.forEach(entry => {
                    if (entry.linkedSource !== 'INSURANCE_PARTIAL_WITHDRAWAL') return;
                    if (!entry.linkedAssetId) return;
                    const amount = Number(entry.amount || 0);
                    const dateKey = (Array.isArray(entry.oneTimeDates) && entry.oneTimeDates.length > 0)
                        ? entry.oneTimeDates[0]
                        : (entry.startDate || '');

                    if (!statsByAssetId[entry.linkedAssetId]) {
                        statsByAssetId[entry.linkedAssetId] = {
                            count: 0,
                            totalAmount: 0,
                            latestDate: ''
                        };
                    }

                    const current = statsByAssetId[entry.linkedAssetId];
                    current.count += 1;
                    current.totalAmount += (Number.isFinite(amount) ? amount : 0);
                    if (dateKey && (!current.latestDate || dateKey > current.latestDate)) {
                        current.latestDate = dateKey;
                    }
                });
                return statsByAssetId;
            }, [cashflowEntries]);

            const insurancePartialWithdrawalRecordsByAssetId = useMemo(() => {
                const recordsByAssetId = {};
                cashflowEntries.forEach(entry => {
                    if (entry.linkedSource !== 'INSURANCE_PARTIAL_WITHDRAWAL') return;
                    if (!entry.linkedAssetId) return;
                    if (!recordsByAssetId[entry.linkedAssetId]) recordsByAssetId[entry.linkedAssetId] = [];
                    const normalizedDate = (Array.isArray(entry.oneTimeDates) && entry.oneTimeDates.length > 0)
                        ? entry.oneTimeDates[0]
                        : (entry.startDate || '');
                    recordsByAssetId[entry.linkedAssetId].push({
                        id: entry.id,
                        amount: Number(entry.amount || 0),
                        date: normalizedDate,
                        accountId: entry.targetLiquidAssetId || '',
                        note: (entry.note || '').trim(),
                        currency: entry.currency || 'HKD'
                    });
                });
                Object.keys(recordsByAssetId).forEach(assetId => {
                    recordsByAssetId[assetId].sort((a, b) => (b.date || '').localeCompare(a.date || ''));
                });
                return recordsByAssetId;
            }, [cashflowEntries]);

            const cashflowAccountOptions = useMemo(() => {
                return [...new Set(assets.map(item => (item.account || '').trim()).filter(Boolean))]
                    .sort((a, b) => a.localeCompare(b, 'zh-Hant', { sensitivity: 'base' }));
            }, [assets]);

            const availableCashflowCategories = useMemo(() => {
                return CASHFLOW_CATEGORY_BY_TYPE[cashflowForm.type] || CASHFLOW_CATEGORY_BY_TYPE.EXPENSE;
            }, [cashflowForm.type]);

            const filteredCashflowEntries = useMemo(() => {
                const keyword = (cashflowRuleKeyword || '').trim().toLowerCase();
                const byFilter = cashflowEntries.filter(item => {
                    if (cashflowRuleFilter === 'ALL') return true;
                    if (cashflowRuleFilter === 'AUTO') return item.scheduleType !== 'ONE_TIME';
                    if (cashflowRuleFilter === 'ONE_TIME') return item.scheduleType === 'ONE_TIME';
                    if (cashflowRuleFilter === 'INCOME') return item.type === 'INCOME';
                    if (cashflowRuleFilter === 'EXPENSE') return item.type === 'EXPENSE';
                    return true;
                });

                const byKeyword = keyword
                    ? byFilter.filter(item => {
                        const fullText = [item.title, item.category, item.account, item.note, item.startDate, item.endDate]
                            .filter(Boolean)
                            .join(' ')
                            .toLowerCase();
                        return fullText.includes(keyword);
                    })
                    : byFilter;

                if (cashflowRuleSortMode === 'NEXT_TRIGGER_ASC') {
                    return [...byKeyword].sort((a, b) => {
                        const aNext = findNextOccurrenceDateKey(a, new Date());
                        const bNext = findNextOccurrenceDateKey(b, new Date());
                        if (!aNext && !bNext) return (a.title || '').localeCompare((b.title || ''), 'zh-Hant', { sensitivity: 'base' });
                        if (!aNext) return 1;
                        if (!bNext) return -1;
                        const byNext = aNext.localeCompare(bNext);
                        if (byNext !== 0) return byNext;
                        return (a.title || '').localeCompare((b.title || ''), 'zh-Hant', { sensitivity: 'base' });
                    });
                }

                return [...byKeyword].sort((a, b) => {
                    const byStart = b.startDate.localeCompare(a.startDate);
                    if (byStart !== 0) return byStart;
                    return (a.title || '').localeCompare((b.title || ''), 'zh-Hant', { sensitivity: 'base' });
                });
            }, [cashflowEntries, cashflowRuleFilter, cashflowRuleKeyword, cashflowRuleSortMode]);

            const cashflowTriggerInfoById = useMemo(() => {
                const map = {};
                const today = new Date();
                filteredCashflowEntries.slice(0, cashflowRulesVisibleCount).forEach(entry => {
                    const lastScheduled = findLastOccurrenceDateKey(entry, today);
                    const nextScheduled = findNextOccurrenceDateKey(entry, today);

                    let lastApplied = '';
                    Object.keys(cashflowAppliedPostings).forEach(postingKey => {
                        const posting = cashflowAppliedPostings[postingKey];
                        if (!posting || posting.entryId !== entry.id) return;
                        const dateKey = parseOccurrenceDateFromPostingKey(postingKey);
                        if (!dateKey) return;
                        if (!lastApplied || dateKey > lastApplied) lastApplied = dateKey;
                    });

                    map[entry.id] = {
                        lastDateKey: lastApplied || lastScheduled || '',
                        nextDateKey: nextScheduled || ''
                    };
                });
                return map;
            }, [filteredCashflowEntries, cashflowRulesVisibleCount, cashflowAppliedPostings]);

            useEffect(() => {
                setCashflowRulesVisibleCount(20);
            }, [cashflowRuleFilter, cashflowRuleKeyword, cashflowRuleSortMode]);

            useEffect(() => {
                if (availableCashflowCategories.includes(cashflowForm.category)) return;
                setCashflowForm(prev => ({
                    ...prev,
                    category: getDefaultCashflowCategory(prev.type)
                }));
            }, [availableCashflowCategories, cashflowForm.category]);

            useEffect(() => {
                if (!cashflowForm.targetLiquidAssetId) return;
                if (liquidAssetOptions.some(option => option.id === cashflowForm.targetLiquidAssetId)) return;
                setCashflowForm(prev => ({
                    ...prev,
                    targetLiquidAssetId: ''
                }));
            }, [cashflowForm.targetLiquidAssetId, liquidAssetOptions]);

            const parseInsuranceInvestmentFundRows = (rawValue) => {
                const lines = String(rawValue || '')
                    .split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(Boolean);
                return lines.map(line => {
                    const parts = line.split(/\||｜/).map(part => part.trim());
                    return {
                        allocationPercent: parts[0] || '',
                        investmentOption: parts[1] || '',
                        codeCurrency: parts[2] || '',
                        profitLossPercent: parts[3] || '',
                        balance: parts[4] || '',
                        units: parts[5] || '',
                        unitPrice: parts[6] || '',
                        averagePrice: parts[7] || ''
                    };
                });
            };

            const serializeInsuranceInvestmentFundRows = (rows) => rows
                .map(row => {
                    const allocationPercent = String(row.allocationPercent || '').trim();
                    const investmentOption = String(row.investmentOption || '').trim();
                    const codeCurrency = String(row.codeCurrency || '').trim();
                    const profitLossPercent = String(row.profitLossPercent || '').trim();
                    const balance = String(row.balance || '').trim();
                    const units = String(row.units || '').trim();
                    const unitPrice = String(row.unitPrice || '').trim();
                    const averagePrice = String(row.averagePrice || '').trim();
                    if (!allocationPercent && !investmentOption && !codeCurrency && !profitLossPercent && !balance && !units && !unitPrice && !averagePrice) return '';
                    return [allocationPercent, investmentOption, codeCurrency, profitLossPercent, balance, units, unitPrice, averagePrice].join('｜');
                })
                .filter(Boolean)
                .join('\n');

            const parsePositiveNumberLoose = (value) => {
                const normalized = String(value || '').replace(/,/g, '').trim();
                const parsed = Number(normalized);
                return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
            };

            const roundForFundField = (value) => {
                const parsed = Number(value || 0);
                if (!Number.isFinite(parsed)) return '';
                return String(Number(parsed.toFixed(6)));
            };

            const normalizeComputedInvestmentRows = (rows) => {
                const normalizedRows = (Array.isArray(rows) ? rows : []).map(row => {
                    const units = parsePositiveNumberLoose(row.units);
                    const unitPrice = parsePositiveNumberLoose(row.unitPrice);
                    const averagePrice = parsePositiveNumberLoose(row.averagePrice);
                    const computedBalance = units > 0 && unitPrice > 0
                        ? (units * unitPrice)
                        : parsePositiveNumberLoose(row.balance);
                    const computedPnlPercent = averagePrice > 0 && unitPrice > 0
                        ? (((unitPrice - averagePrice) / averagePrice) * 100)
                        : parsePositiveNumberLoose(row.profitLossPercent);
                    return {
                        ...row,
                        balance: roundForFundField(computedBalance),
                        profitLossPercent: roundForFundField(computedPnlPercent)
                    };
                });

                const totalBalance = normalizedRows.reduce((sum, row) => sum + parsePositiveNumberLoose(row.balance), 0);
                return normalizedRows.map(row => {
                    const balance = parsePositiveNumberLoose(row.balance);
                    const allocationPercent = totalBalance > 0 ? ((balance / totalBalance) * 100) : 0;
                    return {
                        ...row,
                        allocationPercent: roundForFundField(allocationPercent)
                    };
                });
            };

            const updateInsuranceInvestmentFundItems = (assetId, updater) => {
                setAssets(prevAssets => prevAssets.map(asset => {
                    if (!asset || asset.id !== assetId) return asset;
                    if (asset.category !== 'INSURANCE') return asset;
                    const rows = parseInsuranceInvestmentFundRows(asset.insuranceInvestmentFundItems || '');
                    const nextRowsRaw = typeof updater === 'function' ? updater(rows) : rows;
                    const nextRowsSource = Array.isArray(nextRowsRaw) && nextRowsRaw.length > 0
                        ? nextRowsRaw
                        : [{ allocationPercent: '', investmentOption: '', codeCurrency: '', profitLossPercent: '', balance: '', units: '', unitPrice: '', averagePrice: '' }];
                    const nextRows = normalizeComputedInvestmentRows(nextRowsSource);

                    const nextPolicyValue = nextRows.reduce((sum, row) => {
                        const balance = parsePositiveNumberLoose(row.balance);
                        const units = parsePositiveNumberLoose(row.units);
                        const unitPrice = parsePositiveNumberLoose(row.unitPrice);
                        if (balance > 0) return sum + balance;
                        if (units > 0 && unitPrice > 0) return sum + (units * unitPrice);
                        return sum;
                    }, 0);

                    return {
                        ...asset,
                        insuranceInvestmentFundItems: serializeInsuranceInvestmentFundRows(nextRows),
                        insurancePolicyValue: Number(nextPolicyValue.toFixed(6)),
                        currentPrice: Number(nextPolicyValue.toFixed(6)),
                        quantity: 1
                    };
                }));
            };

            const handleInsuranceFundRowFieldChange = (assetId, rowIndex, field, value) => {
                updateInsuranceInvestmentFundItems(assetId, rows => rows.map((row, index) => (
                    index === rowIndex ? { ...row, [field]: value } : row
                )));
            };

            const handleInsuranceFundAddRow = (assetId) => {
                updateInsuranceInvestmentFundItems(assetId, rows => ([
                    ...rows,
                    { allocationPercent: '', investmentOption: '', codeCurrency: '', profitLossPercent: '', balance: '', units: '', unitPrice: '', averagePrice: '' }
                ]));
            };

            const handleInsuranceFundAppendRowWithData = (assetId, rowData) => {
                const nextRow = {
                    allocationPercent: String(rowData?.allocationPercent || ''),
                    investmentOption: String(rowData?.investmentOption || ''),
                    codeCurrency: String(rowData?.codeCurrency || ''),
                    profitLossPercent: String(rowData?.profitLossPercent || ''),
                    balance: String(rowData?.balance || ''),
                    units: String(rowData?.units || ''),
                    unitPrice: String(rowData?.unitPrice || ''),
                    averagePrice: String(rowData?.averagePrice || '')
                };
                updateInsuranceInvestmentFundItems(assetId, rows => ([...rows, nextRow]));
            };

            const handleInsuranceFundRemoveRow = (assetId, rowIndex) => {
                updateInsuranceInvestmentFundItems(assetId, rows => rows.filter((_, index) => index !== rowIndex));
            };

            const handleInsuranceFundMoveRow = (assetId, rowIndex, direction) => {
                updateInsuranceInvestmentFundItems(assetId, rows => {
                    const targetIndex = rowIndex + direction;
                    if (targetIndex < 0 || targetIndex >= rows.length) return rows;
                    const nextRows = [...rows];
                    const [moved] = nextRows.splice(rowIndex, 1);
                    nextRows.splice(targetIndex, 0, moved);
                    return nextRows;
                });
            };

            const handleInsuranceFundDuplicateRow = (assetId, rowIndex) => {
                updateInsuranceInvestmentFundItems(assetId, rows => {
                    const source = rows[rowIndex];
                    if (!source) return rows;
                    const nextRows = [...rows];
                    nextRows.splice(rowIndex + 1, 0, { ...source });
                    return nextRows;
                });
            };

            const handleInsuranceFundClearRows = (assetId) => {
                updateInsuranceInvestmentFundItems(assetId, () => ([
                    { allocationPercent: '', investmentOption: '', codeCurrency: '', profitLossPercent: '', balance: '', units: '', unitPrice: '', averagePrice: '' }
                ]));
            };

            useEffect(() => {
                const result = applyAutoCashflowPostings({
                    assets,
                    cashflowEntries,
                    cashflowAppliedOccurrenceKeys,
                    cashflowAppliedPostings,
                    cashflowLastAutoApplyDate,
                    toHKD,
                    fromHKD
                });
                if (!result) return;

                if (result.updated) {
                    const previousPostingKeySet = new Set(Object.keys(cashflowAppliedPostings || {}));
                    const newlyAppliedPostingKeys = Object.keys(result.nextAppliedPostings || {}).filter(key => !previousPostingKeySet.has(key));
                    const entryById = {};
                    cashflowEntries.forEach(entry => {
                        if (!entry || !entry.id) return;
                        entryById[entry.id] = entry;
                    });

                    const nextAssetsWithInvestmentLifecycle = [...result.nextAssets];
                    const insuranceAssetIndexMap = {};
                    nextAssetsWithInvestmentLifecycle.forEach((asset, index) => {
                        if (asset.category === 'INSURANCE') insuranceAssetIndexMap[asset.id] = index;
                    });

                    newlyAppliedPostingKeys.forEach(postingKey => {
                        const posting = result.nextAppliedPostings?.[postingKey];
                        if (!posting || typeof posting !== 'object') return;
                        const entryId = typeof posting.entryId === 'string' ? posting.entryId : '';
                        const sourceEntry = entryById[entryId];
                        if (!sourceEntry || sourceEntry.linkedSource !== 'INSURANCE_AUTO') return;

                        const linkedAssetId = sourceEntry.linkedAssetId || '';
                        const insuranceIndex = insuranceAssetIndexMap[linkedAssetId];
                        if (!Number.isInteger(insuranceIndex)) return;

                        const insuranceAsset = nextAssetsWithInvestmentLifecycle[insuranceIndex];
                        if (!insuranceAsset || insuranceAsset.category !== 'INSURANCE') return;
                        const isInvestmentLinkedSubtype = ['投資型壽險', '投資/投資相連'].includes(insuranceAsset.subtype);
                        if (!isInvestmentLinkedSubtype) return;

                        const rows = parseInsuranceInvestmentFundRows(insuranceAsset.insuranceInvestmentFundItems || '');
                        if (!rows.length) return;

                        const entryAmount = Math.abs(Number(sourceEntry.amount || 0));
                        if (!Number.isFinite(entryAmount) || entryAmount <= 0) return;
                        const entryCurrency = sourceEntry.currency || insuranceAsset.currency || 'HKD';
                        const policyCurrency = insuranceAsset.currency || 'HKD';
                        const investmentAmount = fromHKD(toHKD(entryAmount, entryCurrency), policyCurrency);
                        if (!Number.isFinite(investmentAmount) || investmentAmount <= 0) return;

                        const normalizedRowsForAllocation = normalizeComputedInvestmentRows(rows);
                        const positiveAllocationTotal = normalizedRowsForAllocation.reduce((acc, row) => {
                            return acc + parsePositiveNumberLoose(row.allocationPercent);
                        }, 0);
                        const fallbackRatio = normalizedRowsForAllocation.length > 0 ? (1 / normalizedRowsForAllocation.length) : 0;

                        let hasAppliedPurchase = false;
                        const nextRowsBeforeNormalize = normalizedRowsForAllocation.map(row => {
                            const allocationPercent = parsePositiveNumberLoose(row.allocationPercent);
                            const ratio = positiveAllocationTotal > 0
                                ? (allocationPercent > 0 ? (allocationPercent / positiveAllocationTotal) : 0)
                                : fallbackRatio;
                            const allocationAmount = investmentAmount * ratio;
                            if (!Number.isFinite(allocationAmount) || allocationAmount <= 0) return row;

                            const latestUnitPrice = parsePositiveNumberLoose(row.unitPrice) || parsePositiveNumberLoose(row.averagePrice);
                            if (!Number.isFinite(latestUnitPrice) || latestUnitPrice <= 0) return row;

                            const previousUnits = parsePositiveNumberLoose(row.units);
                            const previousAveragePrice = parsePositiveNumberLoose(row.averagePrice);
                            const previousCost = previousUnits * previousAveragePrice;

                            const purchasedUnits = allocationAmount / latestUnitPrice;
                            const nextUnits = previousUnits + purchasedUnits;
                            const nextCost = previousCost + allocationAmount;
                            const nextAveragePrice = nextUnits > 0 ? (nextCost / nextUnits) : 0;
                            const nextBalance = nextUnits * latestUnitPrice;
                            const nextProfitLossPercent = nextAveragePrice > 0
                                ? ((latestUnitPrice - nextAveragePrice) / nextAveragePrice) * 100
                                : 0;

                            hasAppliedPurchase = true;
                            return {
                                ...row,
                                units: roundForFundField(nextUnits),
                                averagePrice: roundForFundField(nextAveragePrice),
                                unitPrice: roundForFundField(latestUnitPrice),
                                balance: roundForFundField(nextBalance),
                                profitLossPercent: roundForFundField(nextProfitLossPercent)
                            };
                        });

                        if (!hasAppliedPurchase) return;
                        const nextRows = normalizeComputedInvestmentRows(nextRowsBeforeNormalize);

                        const policyValueByRows = nextRows.reduce((sum, row) => {
                            const units = parsePositiveNumberLoose(row.units);
                            const unitPrice = parsePositiveNumberLoose(row.unitPrice);
                            const balance = parsePositiveNumberLoose(row.balance);
                            if (balance > 0) return sum + balance;
                            if (units > 0 && unitPrice > 0) return sum + (units * unitPrice);
                            return sum;
                        }, 0);
                        const previousCostBasis = Number(insuranceAsset.costBasis || 0);

                        nextAssetsWithInvestmentLifecycle[insuranceIndex] = {
                            ...insuranceAsset,
                            insuranceInvestmentFundItems: serializeInsuranceInvestmentFundRows(nextRows),
                            insurancePolicyValue: Number(policyValueByRows.toFixed(6)),
                            currentPrice: Number(policyValueByRows.toFixed(6)),
                            quantity: 1,
                            costBasis: Number((Math.max(0, previousCostBasis) + investmentAmount).toFixed(6)),
                            insuranceLastInvestmentDate: parseOccurrenceDateFromPostingKey(postingKey) || ''
                        };
                    });

                    setAssets(nextAssetsWithInvestmentLifecycle);
                    setCashflowAppliedOccurrenceKeys(result.nextAppliedOccurrenceKeys);
                    setCashflowAppliedPostings(result.nextAppliedPostings);
                    setPriceStatus(getCashflowAutoAppliedMessage(pageLanguage, result.appliedCount));
                }
                setCashflowLastAutoApplyDate(result.todayKey);
            }, [assets, cashflowEntries, cashflowAppliedOccurrenceKeys, cashflowAppliedPostings, cashflowLastAutoApplyDate, currencyRates]);

            const selectedCashflowDate = useMemo(() => {
                if (!/^\d{4}-\d{2}$/.test(selectedCashflowMonth || '')) return new Date(new Date().getFullYear(), new Date().getMonth(), 1);
                const [year, month] = selectedCashflowMonth.split('-').map(Number);
                return new Date(year, month - 1, 1);
            }, [selectedCashflowMonth]);

            const cashflowMonthData = useMemo(() => {
                return buildCashflowMonthData({
                    cashflowEntries,
                    selectedCashflowDate,
                    displayCurrency,
                    toHKD,
                    fromHKD
                });
            }, [cashflowEntries, selectedCashflowDate, displayCurrency, currencyRates]);

            const cashflowYearData = useMemo(() => {
                return buildCashflowYearData({
                    cashflowEntries,
                    selectedCashflowDate,
                    displayCurrency,
                    toHKD,
                    fromHKD
                });
            }, [cashflowEntries, selectedCashflowDate, displayCurrency, currencyRates]);

            const moveCashflowMonth = (delta) => {
                const next = new Date(cashflowMonthData.year, cashflowMonthData.month + delta, 1);
                setSelectedCashflowMonth(toMonthKey(next));
            };

            const startNewAssetEntry = () => {
                setEditingId(null);
                setFormData(createInitialAssetFormData());
                setFinanceSectionTab('ASSET_ACCOUNT');
                setIsModalOpen(true);
            };

            const startNewCashflowEntry = () => {
                setEditingCashflowId('');
                setCashflowForm(createInitialCashflowForm());
                setFinanceSectionTab('CASHFLOW');
                setPriceStatus(getCashflowStartNewMessage(pageLanguage));
                setIsCashflowModalOpen(true);
            };

            const startEditCashflowEntry = (entry) => {
                setEditingCashflowId(entry.id);
                setCashflowForm(buildCashflowFormFromEntry({
                    entry,
                    getDefaultCashflowCategory,
                    toDateKey,
                    parseDateKey
                }));
                setFinanceSectionTab('CASHFLOW');
                setPriceStatus(getCashflowStartEditMessage(pageLanguage));
                setIsCashflowModalOpen(true);
            };

            const handleCashflowSubmit = (event) => {
                event.preventDefault();
                const submission = buildCashflowSubmission({
                    cashflowForm,
                    editingCashflowId,
                    liquidAssetOptions,
                    parseDateKey,
                    getDefaultCashflowCategory,
                    tByLang
                });

                if (!submission.ok) {
                    showSubmissionErrorAlert(submission.error);
                    return;
                }

                if (submission.isEditing) {
                    const prevEntry = cashflowEntries.find(item => item.id === editingCashflowId);
                    const nextTargetId = submission.nextEntry.targetLiquidAssetId || '';
                    const prevTargetId = prevEntry?.targetLiquidAssetId || '';

                    if (prevEntry && prevTargetId !== nextTargetId) {
                        const liquidAssetIndexMap = {};
                        const nextAssets = [...assets];
                        nextAssets.forEach((asset, index) => {
                            if (asset.category === 'LIQUID') liquidAssetIndexMap[asset.id] = index;
                        });

                        const nextAppliedPostings = { ...cashflowAppliedPostings };
                        const nextAppliedKeySet = new Set(cashflowAppliedOccurrenceKeys);

                        Object.keys(cashflowAppliedPostings).forEach(postingKey => {
                            const posting = cashflowAppliedPostings[postingKey];
                            if (!posting || posting.entryId !== editingCashflowId) return;

                            const oldTargetId = posting.targetLiquidAssetId || prevTargetId;
                            const oldIndex = liquidAssetIndexMap[oldTargetId];
                            if (Number.isInteger(oldIndex)) {
                                const oldAsset = nextAssets[oldIndex];
                                if (oldAsset && oldAsset.category === 'LIQUID') {
                                    const nextQuantity = Number(oldAsset.quantity || 0) - Number(posting.signedAmount || 0);
                                    nextAssets[oldIndex] = {
                                        ...oldAsset,
                                        quantity: Number(nextQuantity.toFixed(6))
                                    };
                                }
                            }

                            delete nextAppliedPostings[postingKey];
                            nextAppliedKeySet.delete(postingKey);

                            if (!nextTargetId) return;
                            const nextIndex = liquidAssetIndexMap[nextTargetId];
                            if (!Number.isInteger(nextIndex)) return;

                            const nextAsset = nextAssets[nextIndex];
                            if (!nextAsset || nextAsset.category !== 'LIQUID') return;

                            const amountHKD = toHKD(Number(posting.signedAmount || 0), posting.targetCurrency || nextAsset.currency);
                            const signedAmount = fromHKD(amountHKD, nextAsset.currency);
                            const nextQuantity = Number(nextAsset.quantity || 0) + signedAmount;
                            nextAssets[nextIndex] = {
                                ...nextAsset,
                                quantity: Number(nextQuantity.toFixed(6))
                            };

                            const dateKey = parseOccurrenceDateFromPostingKey(postingKey);
                            const nextKey = dateKey
                                ? `${editingCashflowId}@${dateKey}@${nextTargetId}`
                                : `${editingCashflowId}@${nextTargetId}`;
                            nextAppliedPostings[nextKey] = {
                                ...posting,
                                targetLiquidAssetId: nextTargetId,
                                signedAmount: Number(signedAmount.toFixed(6)),
                                targetCurrency: nextAsset.currency
                            };
                            nextAppliedKeySet.add(nextKey);
                        });

                        setAssets(nextAssets);
                        setCashflowAppliedPostings(nextAppliedPostings);
                        setCashflowAppliedOccurrenceKeys(Array.from(nextAppliedKeySet));
                    }

                    setCashflowEntries(prev => sanitizeCashflowEntries(prev.map(item => item.id === editingCashflowId ? submission.nextEntry : item)));
                } else {
                    setCashflowEntries(prev => sanitizeCashflowEntries([...prev, submission.nextEntry]));
                }
                setCashflowForm(prev => ({
                    ...prev,
                    title: '',
                    amount: '',
                    note: '',
                    oneTimeDates: [],
                    targetLiquidAssetId: prev.targetLiquidAssetId || ''
                }));
                setEditingCashflowId('');

                const statusMessage = buildCashflowSubmitStatus({
                    isEditing: submission.isEditing,
                    selectedLiquidAsset: submission.selectedLiquidAsset,
                    nextEntry: submission.nextEntry,
                    amount: submission.amount,
                    cashflowCurrency: cashflowForm.currency,
                    toHKD,
                    fromHKD,
                    formatAmount,
                    isEntryOnDate,
                    tByLang
                });
                setPriceStatus(statusMessage);
                setIsCashflowModalOpen(false);
            };

            const handleDeleteCashflowEntry = (id) => {
                const {
                    targetRule,
                    targetPostingKeys,
                    rollbackByAsset
                } = collectCashflowDeleteContext({
                    ruleId: id,
                    cashflowEntries,
                    cashflowAppliedPostings
                });

                const rollbackPreviewLines = [];
                if (targetPostingKeys.length > 0) {
                    rollbackByAsset.forEach(item => {
                        const label = liquidAssetLabelById[item.assetId] || getCashflowLinkedAccountLabel(pageLanguage);
                        const rollbackAmount = Number(item.amount || 0);
                        rollbackPreviewLines.push(`- ${label}：${rollbackAmount >= 0 ? '-' : '+'}${formatAmount(Math.abs(rollbackAmount))} ${item.currency}`);
                    });
                }

                const confirmMessage = getCashflowDeleteConfirmMessage(pageLanguage, {
                    ruleTitle: targetRule?.title,
                    rollbackPreviewLines
                });

                if (!showConfirmDialog(confirmMessage)) return;

                const nextAppliedPostings = { ...cashflowAppliedPostings };
                const nextAppliedKeySet = new Set(cashflowAppliedOccurrenceKeys);

                if (targetRule?.targetLiquidAssetId && targetPostingKeys.length > 0) {
                    const { nextAssets, revertedCount } = rollbackCashflowPostingsOnLiquidAssets({
                        assets,
                        cashflowAppliedPostings,
                        targetPostingKeys
                    });
                    targetPostingKeys.forEach(postingKey => {
                        delete nextAppliedPostings[postingKey];
                        nextAppliedKeySet.delete(postingKey);
                    });

                    setAssets(nextAssets);
                    setCashflowAppliedPostings(nextAppliedPostings);
                    setCashflowAppliedOccurrenceKeys(Array.from(nextAppliedKeySet));
                    setPriceStatus(getCashflowDeleteRollbackMessage(pageLanguage, revertedCount));
                } else {
                    if (targetPostingKeys.length > 0) {
                        targetPostingKeys.forEach(postingKey => {
                            delete nextAppliedPostings[postingKey];
                            nextAppliedKeySet.delete(postingKey);
                        });
                        setCashflowAppliedPostings(nextAppliedPostings);
                        setCashflowAppliedOccurrenceKeys(Array.from(nextAppliedKeySet));
                    }
                    setPriceStatus(getCashflowDeleteMessage(pageLanguage));
                }

                setCashflowEntries(prev => prev.filter(item => item.id !== id));
                if (editingCashflowId === id) {
                    setEditingCashflowId('');
                    setIsCashflowModalOpen(false);
                }
            };

            const cancelCashflowEdit = () => {
                setEditingCashflowId('');
                setCashflowForm(prev => ({
                    ...prev,
                    title: '',
                    amount: '',
                    note: '',
                    oneTimeDates: []
                }));
                setIsCashflowModalOpen(false);
                setPriceStatus(getCashflowEditCanceledMessage(pageLanguage));
            };

            const isCashflowOneTime = cashflowForm.scheduleType === 'ONE_TIME';
            const isCashflowMonthlyRecurring = !isCashflowOneTime && cashflowForm.frequency === 'MONTHLY';

            const refreshCurrencyRates = async (showToast = true) => {
                setIsUpdatingRates(true);
                if (showToast) setPriceStatus(getFxUpdatingMessage(pageLanguage));
                try {
                    const { nextRates, stamp } = await refreshCurrencyRatesWithStamp({ fetchLatestCurrencyRates });
                    setCurrencyRates(nextRates);
                    setLastRateUpdate(stamp);
                    if (showToast) setPriceStatus(getFxUpdatedMessage(pageLanguage));
                    return nextRates;
                } catch (error) {
                    if (showToast) setPriceStatus(getFxUpdateFailedMessage(pageLanguage));
                    return null;
                } finally {
                    setIsUpdatingRates(false);
                }
            };

            useEffect(() => {
                if (!CATEGORY_KEYS.includes(selectedStatsCategory)) {
                    setSelectedStatsCategory('INVEST');
                }
            }, [selectedStatsCategory]);

            useEffect(() => {
                if (!accountStats.accountNames.length) {
                    setSelectedStatsAccount('');
                    setSelectedStatsSegmentKey('');
                    return;
                }

                if (!accountStats.accountNames.includes(selectedStatsAccount)) {
                    setSelectedStatsAccount(accountStats.accountNames[0]);
                }

                if (!accountStats.segments.some(item => item.key === selectedStatsSegmentKey)) {
                    setSelectedStatsSegmentKey(accountStats.segments[0]?.key || '');
                }
            }, [accountStats.accountNames, accountStats.segments, selectedStatsAccount, selectedStatsSegmentKey]);

            const updateMarketPrices = async (showToast = true, ratesOverride = null) => {
                const latestAssets = assetsRef.current;
                const {
                    stockTargets,
                    cryptoTargets,
                    stockSymbolMap,
                    stockSymbols,
                    cryptoSymbols
                } = buildMarketTargets({ assets: latestAssets, normalizeYahooSymbol });

                if (!stockTargets.length && !cryptoTargets.length) {
                    if (showToast) setPriceStatus(getMarketNoSymbolsMessage(pageLanguage));
                    return;
                }

                setIsUpdatingPrice(true);
                if (showToast) {
                    setPriceStatus(getMarketUpdatingMessage(pageLanguage));
                }

                const [stockQuotes, cryptoQuotesUSD] = await Promise.all([
                    fetchYahooQuotes(stockSymbols),
                    fetchCryptoQuotes(cryptoSymbols)
                ]);

                let finalUpdatedCount = 0;
                setAssets(prev => {
                    const {
                        nextAssets,
                        updatedCount
                    } = applyQuotePricesToAssets({
                        assets: prev,
                        stockSymbolMap,
                        stockQuotes,
                        cryptoQuotesUSD,
                        currencyRates: ratesOverride || currencyRates,
                        defaultUsdRate: DEFAULT_RATES.USD
                    });
                    finalUpdatedCount = updatedCount;
                    return updatedCount > 0 ? nextAssets : prev;
                });

                const stamp = new Date();
                setLastPriceUpdate(stamp);
                setIsUpdatingPrice(false);
                if (showToast) {
                    setPriceStatus(finalUpdatedCount > 0
                        ? getMarketUpdatedCountMessage(pageLanguage, finalUpdatedCount)
                        : getMarketUpToDateMessage(pageLanguage));
                }
            };

            const updateMarketAndRates = async ({ updateMarket = true, updateRates = true, showToast = true } = {}) => {
                if (showToast) {
                    setPriceStatus(getMarketAndFxUpdatingMessage(pageLanguage));
                }
                let latestRates = null;
                if (updateRates) {
                    latestRates = await refreshCurrencyRates(false);
                }
                if (updateMarket) {
                    await updateMarketPrices(false, latestRates);
                }
                if (showToast) {
                    setPriceStatus(getMarketAndFxUpdatedMessage(pageLanguage));
                }
            };

            useEffect(() => {
                if (!isCloudEnabled) {
                    setIsAuthLoading(false);
                    return;
                }

                firebaseAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
                    .catch(() => {
                        setCloudStatusWithMode((lang) => getCloudPersistenceFailedMessage(lang), 'action');
                    });

                firebaseAuth.getRedirectResult()
                    .then(result => {
                        if (result?.user) {
                            setCloudAuthState({ status: 'signed-in', email: result.user.email || '' });
                            setCloudStatusMode('auth');
                        }
                    })
                    .catch(error => {
                        const code = error?.code || 'unknown';
                        const messageText = String(error?.message || '').toLowerCase();
                        if (messageText.includes('redirect_uri_mismatch') || code === 'auth/invalid-credential') {
                            setCloudStatusWithMode((lang) => getCloudRedirectUriMismatchHelpMessage(lang), 'action');
                            return;
                        }
                        setCloudStatusWithMode((lang) => getCloudRedirectSignInFailedMessage(lang, code), 'action');
                    });

                const unsubscribe = firebaseAuth.onAuthStateChanged(async (user) => {
                    setAuthUser(user || null);
                    setIsAuthLoading(false);

                    if (!user) {
                        setCloudAuthState({ status: 'signed-out', email: '' });
                        setCloudStatusMode('auth');
                        return;
                    }

                    setCloudAuthState({ status: 'signed-in-manual', email: user.email || '' });
                    setCloudStatusMode('auth');
                });

                return () => unsubscribe();
            }, []);

            const handleCloudDownload = async () => {
                if (!isCloudEnabled) {
                    setCloudStatusWithMode((lang) => getCloudFirebaseNotConfiguredMessage(lang), 'action');
                    return;
                }
                if (!authUser) {
                    setCloudStatusWithMode((lang) => getCloudSignInRequiredMessage(lang), 'action');
                    return;
                }

                setIsCloudSyncing(true);
                setCloudStatusWithMode((lang) => getCloudDownloadingMessage(lang), 'action');

                try {
                    const result = await downloadCloudData({
                        firebaseDB,
                        collectionName: CLOUD_COLLECTION,
                        user: authUser,
                    });

                    if (result.hydrated) {
                        const hydrated = result.hydrated;
                        applyHydratedCloudSnapshot({
                            hydrated,
                            storageKeys: STORAGE_KEYS,
                            setAssets,
                            setDisplayCurrency,
                            setMonthlySnapshots,
                            setCashflowEntries,
                            setCashflowAppliedOccurrenceKeys,
                            setCashflowAppliedPostings,
                            setCashflowLastAutoApplyDate
                        });
                        setCloudStatusWithMode((lang) => getCloudDownloadedMessage(lang, authUser.email), 'action');
                    } else if (result.hasSnapshot) {
                        setCloudStatusWithMode((lang) => getCloudInvalidDataMessage(lang), 'action');
                    } else {
                        setCloudStatusWithMode((lang) => getCloudNoDataMessage(lang), 'action');
                    }
                } catch (error) {
                    setCloudStatusWithMode((lang) => getCloudDownloadFailedMessage(lang), 'action');
                } finally {
                    setIsCloudSyncing(false);
                }
            };

            const handleCloudUpload = async () => {
                if (!isCloudEnabled) {
                    setCloudStatusWithMode((lang) => getCloudFirebaseNotConfiguredMessage(lang), 'action');
                    return;
                }
                if (!authUser) {
                    setCloudStatusWithMode((lang) => getCloudSignInRequiredMessage(lang), 'action');
                    return;
                }

                setIsCloudSyncing(true);
                setCloudStatusWithMode((lang) => getCloudUploadingMessage(lang), 'action');

                try {
                    const payload = buildCloudSyncPayload({
                        assets,
                        displayCurrency,
                        monthlySnapshots,
                        cashflowEntries,
                        cashflowAppliedOccurrenceKeys,
                        cashflowAppliedPostings,
                        cashflowLastAutoApplyDate
                    });

                    await uploadCloudData({
                        firebaseDB,
                        collectionName: CLOUD_COLLECTION,
                        user: authUser,
                        firebase,
                        localPayload: payload
                    });

                    setCloudStatusWithMode((lang) => getCloudUploadedMessage(lang, authUser.email), 'action');
                } catch (error) {
                    setCloudStatusWithMode((lang) => getCloudUploadFailedMessage(lang), 'action');
                } finally {
                    setIsCloudSyncing(false);
                }
            };

            const handleGoogleLogin = async () => {
                await loginWithGoogle({
                    isCloudEnabled,
                    firebaseAuth,
                    firebase,
                    onStatus: (message) => setCloudStatusWithMode(message, 'action'),
                    tByLang,
                    tByLangBy
                });
            };

            const handleGoogleLogout = async () => {
                await logoutGoogle({
                    isCloudEnabled,
                    firebaseAuth,
                    onStatus: (message) => setCloudStatusWithMode(message, 'action'),
                    tByLang,
                    tByLangBy
                });
            };

            const handleExportData = () => {
                try {
                    const payload = buildBackupPayload({
                        assets,
                        displayCurrency,
                        monthlySnapshots,
                        cashflowEntries,
                        cashflowAppliedOccurrenceKeys,
                        cashflowAppliedPostings,
                        cashflowLastAutoApplyDate
                    });
                    const fileName = `asset-tracker-backup-${new Date().toISOString().slice(0, 10)}.json`;
                    downloadJsonFile(payload, fileName);
                    setPriceStatus(getExportSuccessMessage(pageLanguage));
                } catch (error) {
                    setPriceStatus(getExportFailedMessage(pageLanguage));
                }
            };

            const openImportPicker = () => {
                importInputRef.current?.click();
            };

            const handleShareApp = async () => {
                if (isGeneratingPdf) {
                    setPriceStatus(getPdfGeneratingBusyMessage(pageLanguage));
                    return;
                }
                let watchdogTimer = null;
                try {
                    setIsGeneratingPdf(true);

                    watchdogTimer = setTimeout(() => {
                        setIsGeneratingPdf(false);
                        setPriceStatus(getPdfTimeoutMessage(pageLanguage));
                    }, 20000);

                    await exportAssetReportPdf({
                        assets,
                        displayCurrency,
                        pageLanguage,
                        totals,
                        assetMix,
                        groupedAssets,
                        cashflowMonthData,
                        cashflowYearData,
                        cashflowEntries,
                        liquidAssetLabelById,
                        cashflowAppliedPostings,
                        parseOccurrenceDateFromPostingKey,
                        themeTokens: exportThemeTokens,
                        categories: CATEGORIES,
                        formatAmount,
                        toHKD,
                        fromHKD,
                        ensureJsPdfReady,
                        ensureHtml2CanvasReady,
                        onProgress: (message) => setPriceStatus(message)
                    });

                    setPriceStatus(getPdfDownloadedMessage(pageLanguage));
                } catch (error) {
                    setPriceStatus(getPdfShareFailedMessage(pageLanguage, error?.message));
                } finally {
                    if (watchdogTimer) clearTimeout(watchdogTimer);
                    setIsGeneratingPdf(false);
                }
            };

            const handleImportData = async (event) => {
                const file = event.target.files?.[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const parsed = JSON.parse(text);
                    const {
                        nextAssets,
                        nextDisplayCurrency,
                        safeSnapshots,
                        nextCashflowEntries,
                        nextCashflowAppliedOccurrenceKeys,
                        nextCashflowAppliedPostings,
                        nextCashflowLastAutoApplyDate
                    } = parseImportedBackup(parsed, new Date(Date.now() - ONE_DAY_MS));

                    if (!nextAssets || !nextAssets.every(isValidAssetRecord)) {
                        throw new Error('invalid assets format');
                    }

                    if (!nextDisplayCurrency || !CURRENCIES.includes(nextDisplayCurrency)) {
                        throw new Error('invalid display currency');
                    }

                    setAssets(nextAssets.map(normalizeAssetRecord));
                    setDisplayCurrency(nextDisplayCurrency);
                    setMonthlySnapshots(safeSnapshots);
                    setCashflowEntries(nextCashflowEntries);
                    setCashflowAppliedOccurrenceKeys(nextCashflowAppliedOccurrenceKeys);
                    setCashflowAppliedPostings(nextCashflowAppliedPostings);
                    setCashflowLastAutoApplyDate(nextCashflowLastAutoApplyDate);
                    localStorage.setItem(STORAGE_KEYS.monthlySnapshots, JSON.stringify(safeSnapshots));
                    localStorage.setItem(STORAGE_KEYS.cashflowEntries, JSON.stringify(nextCashflowEntries));
                    localStorage.setItem(STORAGE_KEYS.cashflowAppliedOccurrenceKeys, JSON.stringify(nextCashflowAppliedOccurrenceKeys));
                    localStorage.setItem(STORAGE_KEYS.cashflowAppliedPostings, JSON.stringify(nextCashflowAppliedPostings));
                    localStorage.setItem(STORAGE_KEYS.cashflowLastAutoApplyDate, JSON.stringify(nextCashflowLastAutoApplyDate));
                    setPriceStatus(getImportSuccessMessage(pageLanguage, nextAssets.length));
                } catch (error) {
                    setPriceStatus(getImportFailedMessage(pageLanguage));
                } finally {
                    event.target.value = '';
                }
            };

            // 重設為範例資料（會覆蓋 localStorage）
            const resetToSeed = () => {
                if (!showConfirmDialog(getResetSeedConfirmMessage(pageLanguage))) return;
                const normalized = seedAssets.map(normalizeAssetRecord);

                setAssets(normalized);
                setDisplayCurrency('HKD');
                setMonthlySnapshots({});
                setCashflowEntries([]);
                setCashflowAppliedOccurrenceKeys([]);
                setCashflowAppliedPostings({});
                setCashflowLastAutoApplyDate(toDateKey(new Date(Date.now() - ONE_DAY_MS)));

                // 同步寫入 localStorage（useEffect 也會在 state 變更時覆寫，但這裡先寫以確保立即一致）
                try {
                    localStorage.setItem(STORAGE_KEYS.assets, JSON.stringify(normalized));
                    localStorage.setItem(STORAGE_KEYS.displayCurrency, JSON.stringify('HKD'));
                    localStorage.setItem(STORAGE_KEYS.monthlySnapshots, JSON.stringify({}));
                    localStorage.setItem(STORAGE_KEYS.cashflowEntries, JSON.stringify([]));
                    localStorage.setItem(STORAGE_KEYS.cashflowAppliedOccurrenceKeys, JSON.stringify([]));
                    localStorage.setItem(STORAGE_KEYS.cashflowAppliedPostings, JSON.stringify({}));
                    localStorage.setItem(STORAGE_KEYS.cashflowLastAutoApplyDate, JSON.stringify(toDateKey(new Date(Date.now() - ONE_DAY_MS))));
                } catch (e) {
                    // 忽略 storage 錯誤
                }

                setPriceStatus(getDataResetMessage(pageLanguage));
            };

            useEffect(() => {
                updateMarketAndRates({ updateMarket: true, updateRates: true, showToast: false });
                const timer = setInterval(() => updateMarketAndRates({ updateMarket: true, updateRates: false, showToast: false }), 5 * 60 * 1000);
                const rateTimer = setInterval(() => updateMarketAndRates({ updateMarket: false, updateRates: true, showToast: false }), 30 * 60 * 1000);
                return () => {
                    clearInterval(timer);
                    clearInterval(rateTimer);
                };
            }, []);

            const openEdit = (asset) => {
                setEditingId(asset.id);
                setFormData(buildFormDataFromAsset(asset));
                setIsModalOpen(true);
            };

            const loadInsurancePartialWithdrawalRecordForEdit = (recordId) => {
                if (!recordId || !editingId) return;
                const targetEntry = cashflowEntries.find(entry => (
                    entry.id === recordId
                    && entry.linkedSource === 'INSURANCE_PARTIAL_WITHDRAWAL'
                    && entry.linkedAssetId === editingId
                ));
                if (!targetEntry) {
                    showSubmissionErrorAlert(tByLang('找不到該提領紀錄，可能已被刪除。', 'The withdrawal record was not found and may have been deleted.', '対象の引き出し記録が見つかりません。すでに削除された可能性があります。'));
                    return;
                }
                const normalizedDate = (Array.isArray(targetEntry.oneTimeDates) && targetEntry.oneTimeDates.length > 0)
                    ? targetEntry.oneTimeDates[0]
                    : (targetEntry.startDate || '');
                const noteSegments = String(targetEntry.note || '')
                    .split('｜')
                    .map(item => item.trim())
                    .filter(Boolean);
                const extractedCustomNote = noteSegments.length >= 3 ? noteSegments.slice(2).join('｜') : '';
                setFormData(prev => ({
                    ...prev,
                    insurancePartialWithdrawalEditCashflowId: targetEntry.id,
                    insurancePartialWithdrawalAmount: Number(targetEntry.amount || 0) > 0 ? String(targetEntry.amount) : '',
                    insurancePartialWithdrawalDate: normalizedDate,
                    insurancePartialWithdrawalAccountId: targetEntry.targetLiquidAssetId || '',
                    insurancePartialWithdrawalNote: extractedCustomNote
                }));
            };

            const clearInsurancePartialWithdrawalEditTarget = () => {
                setFormData(prev => ({
                    ...prev,
                    insurancePartialWithdrawalEditCashflowId: '',
                    insurancePartialWithdrawalAmount: '',
                    insurancePartialWithdrawalDate: '',
                    insurancePartialWithdrawalAccountId: '',
                    insurancePartialWithdrawalNote: ''
                }));
            };

            const deleteInsurancePartialWithdrawalRecord = (recordId) => {
                if (!recordId || !editingId) return;
                const targetEntry = cashflowEntries.find(entry => (
                    entry.id === recordId
                    && entry.linkedSource === 'INSURANCE_PARTIAL_WITHDRAWAL'
                    && entry.linkedAssetId === editingId
                ));
                if (!targetEntry) {
                    showSubmissionErrorAlert(tByLang('找不到該提領紀錄，可能已被刪除。', 'The withdrawal record was not found and may have been deleted.', '対象の引き出し記録が見つかりません。すでに削除された可能性があります。'));
                    return;
                }

                const confirmMessage = tByLang(
                    `確定刪除此提領紀錄嗎？\n金額：${formatAmount(Number(targetEntry.amount || 0))} ${targetEntry.currency || 'HKD'}\n刪除後會回補保單價值。`,
                    `Delete this withdrawal record?\nAmount: ${formatAmount(Number(targetEntry.amount || 0))} ${targetEntry.currency || 'HKD'}\nPolicy value will be rolled back after deletion.`,
                    `この引き出し記録を削除しますか？\n金額：${formatAmount(Number(targetEntry.amount || 0))} ${targetEntry.currency || 'HKD'}\n削除後、保険価値は戻されます。`
                );
                if (!showConfirmDialog(confirmMessage)) return;

                const rollbackAmount = Number(targetEntry.amount || 0);
                setAssets(prev => prev.map(asset => {
                    if (asset.id !== editingId) return asset;
                    const nextPolicyValue = Math.max(0, Number(asset.insurancePolicyValue || 0) + rollbackAmount);
                    const nextCurrentPrice = Math.max(0, Number(asset.currentPrice || 0) + rollbackAmount);
                    return {
                        ...asset,
                        insurancePolicyValue: nextPolicyValue,
                        currentPrice: nextCurrentPrice
                    };
                }));
                setCashflowEntries(prev => sanitizeCashflowEntries(prev.filter(entry => entry.id !== recordId)));

                setFormData(prev => {
                    if (prev.insurancePartialWithdrawalEditCashflowId !== recordId) return prev;
                    return {
                        ...prev,
                        insurancePartialWithdrawalEditCashflowId: '',
                        insurancePartialWithdrawalAmount: '',
                        insurancePartialWithdrawalDate: '',
                        insurancePartialWithdrawalAccountId: '',
                        insurancePartialWithdrawalNote: ''
                    };
                });
            };

            const handleDelete = (id) => {
                const linkedInsuranceRuleCount = cashflowEntries.filter(entry => (
                    (entry.linkedSource === 'INSURANCE_AUTO' || entry.linkedSource === 'INSURANCE_DISTRIBUTION_AUTO')
                    && entry.linkedAssetId === id
                )).length;
                const linkedFixedDepositRuleCount = cashflowEntries.filter(entry => (
                    entry.linkedSource === 'FIXED_DEPOSIT_MATURITY_AUTO'
                    && entry.linkedAssetId === id
                )).length;
                const linkedBankWealthRuleCount = cashflowEntries.filter(entry => (
                    entry.linkedSource === 'BANK_WEALTH_MATURITY_AUTO'
                    && entry.linkedAssetId === id
                )).length;
                const linkedAutoRuleCount = linkedInsuranceRuleCount + linkedFixedDepositRuleCount + linkedBankWealthRuleCount;
                const confirmMessage = linkedAutoRuleCount > 0
                    ? tByLang(
                        `確定要刪除此資產嗎？\n將一併刪除 ${linkedAutoRuleCount} 條自動現金流規則。`,
                        `Delete this asset?\n${linkedAutoRuleCount} linked auto-cashflow rule(s) will also be removed.`,
                        `この資産を削除しますか？\n連動する自動キャッシュフロールール ${linkedAutoRuleCount} 件も削除されます。`
                    )
                    : tByLang('確定要刪除此資產嗎？', 'Delete this asset?', 'この資産を削除しますか？');
                const result = buildAssetDeleteResult({ assets, id, confirmMessage });
                if (!result.ok) return;
                setAssets(result.nextAssets);
                setCashflowEntries(prev => prev.filter(entry => !(
                    (entry.linkedSource === 'INSURANCE_AUTO' || entry.linkedSource === 'INSURANCE_DISTRIBUTION_AUTO' || entry.linkedSource === 'FIXED_DEPOSIT_MATURITY_AUTO' || entry.linkedSource === 'BANK_WEALTH_MATURITY_AUTO')
                    && entry.linkedAssetId === id
                )));
                setIsModalOpen(false);
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                const previousAsset = editingId ? assets.find(item => item.id === editingId) : null;
                const wasAutoInsurance = Boolean(previousAsset && previousAsset.category === 'INSURANCE');
                const wasAutoFixedDeposit = Boolean(previousAsset && previousAsset.category === 'INVEST' && previousAsset.subtype === '定期存款');
                const wasAutoBankWealth = Boolean(previousAsset && previousAsset.category === 'INVEST' && previousAsset.subtype === '銀行理財');
                const normalizeDistributionStartPolicyYear = (startDateKey, rawValue) => {
                    const parsedRaw = Number(rawValue || 0);
                    if (!Number.isFinite(parsedRaw) || parsedRaw <= 0) return 0;
                    const normalizedRaw = Math.floor(parsedRaw);
                    if (normalizedRaw >= 1000) {
                        const startDate = parseDateKey(startDateKey || '');
                        if (!startDate) return 0;
                        return Math.max(1, normalizedRaw - startDate.getFullYear() + 1);
                    }
                    return normalizedRaw;
                };

                const resolveDistributionStartCalendarYear = (sourceAsset) => {
                    const startDate = parseDateKey(sourceAsset.insuranceStartDate) || new Date();
                    const normalizedRaw = Math.floor(Number(sourceAsset.insuranceDistributionStartPolicyYear || 0));
                    if (Number.isFinite(normalizedRaw) && normalizedRaw >= 1000) {
                        return normalizedRaw;
                    }
                    const policyYear = normalizeDistributionStartPolicyYear(sourceAsset.insuranceStartDate, sourceAsset.insuranceDistributionStartPolicyYear);
                    return startDate.getFullYear() + Math.max(0, policyYear - 1);
                };

                const buildInsuranceCashflowEntry = (assetId, sourceAsset, existingCashflowId = '') => {
                    const selectedLiquidAsset = liquidAssetOptions.find(option => option.id === sourceAsset.insurancePaymentAccountId);
                    const start = parseDateKey(sourceAsset.insuranceStartDate) || new Date();
                    const configuredPaymentDayRaw = Number(sourceAsset.insurancePaymentDay);
                    const configuredPaymentDay = Number.isInteger(configuredPaymentDayRaw) && configuredPaymentDayRaw >= 1 && configuredPaymentDayRaw <= 31
                        ? configuredPaymentDayRaw
                        : start.getDate();
                    const daysInStartMonth = new Date(start.getFullYear(), start.getMonth() + 1, 0).getDate();
                    const targetDay = Math.min(configuredPaymentDay, daysInStartMonth);
                    const adjustedStartDate = toDateKey(new Date(start.getFullYear(), start.getMonth(), targetDay));
                    return {
                        id: existingCashflowId || `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        title: (sourceAsset.name || '').trim() || '保險扣款',
                        account: selectedLiquidAsset?.account || sourceAsset.account || '',
                        category: getDefaultCashflowCategory('EXPENSE'),
                        note: [
                            (sourceAsset.insuranceProvider || '').trim(),
                            (sourceAsset.insurancePolicyNumber || '').trim(),
                            (sourceAsset.insuranceNote || '').trim()
                        ].filter(Boolean).join('｜'),
                        type: 'EXPENSE',
                        amount: Number(sourceAsset.premiumAmount) || 0,
                        currency: sourceAsset.currency || 'HKD',
                        startDate: adjustedStartDate,
                        oneTimeDates: [],
                        endDate: sourceAsset.insuranceEndDate || '',
                        scheduleType: 'RECURRING',
                        frequency: sourceAsset.premiumFrequency === 'yearly' ? 'YEARLY' : 'MONTHLY',
                        weekday: 0,
                        monthday: configuredPaymentDay,
                        payday: String(configuredPaymentDay),
                        targetLiquidAssetId: sourceAsset.insurancePaymentAccountId,
                        linkedAssetId: assetId,
                        linkedSource: 'INSURANCE_AUTO'
                    };
                };

                const buildInsuranceDistributionCashflowEntry = (assetId, sourceAsset, existingCashflowId = '') => {
                    const selectedLiquidAsset = liquidAssetOptions.find(option => option.id === sourceAsset.insurancePaymentAccountId);
                    const start = parseDateKey(sourceAsset.insuranceStartDate) || new Date();
                    const configuredPaymentDayRaw = Number(sourceAsset.insurancePaymentDay);
                    const configuredPaymentDay = Number.isInteger(configuredPaymentDayRaw) && configuredPaymentDayRaw >= 1 && configuredPaymentDayRaw <= 31
                        ? configuredPaymentDayRaw
                        : start.getDate();
                    const distributionYear = resolveDistributionStartCalendarYear(sourceAsset);
                    const daysInDistributionMonth = new Date(distributionYear, start.getMonth() + 1, 0).getDate();
                    const distributionDay = Math.min(configuredPaymentDay, daysInDistributionMonth);
                    const adjustedStartDate = toDateKey(new Date(distributionYear, start.getMonth(), distributionDay));
                    return {
                        id: existingCashflowId || `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        title: (sourceAsset.name || '').trim() ? `${(sourceAsset.name || '').trim()} 派發` : '保險派發',
                        account: selectedLiquidAsset?.account || sourceAsset.account || '',
                        category: getDefaultCashflowCategory('INCOME'),
                        note: [
                            (sourceAsset.insuranceProvider || '').trim(),
                            (sourceAsset.insurancePolicyNumber || '').trim(),
                            tByLang('保險派發（自動）', 'Insurance Distribution (Auto)', '保険配当（自動）')
                        ].filter(Boolean).join('｜'),
                        type: 'INCOME',
                        amount: Number(sourceAsset.insuranceAnnualDistributionAmount) || 0,
                        currency: sourceAsset.currency || 'HKD',
                        startDate: adjustedStartDate,
                        oneTimeDates: [],
                        endDate: sourceAsset.insuranceEndDate || '',
                        scheduleType: 'RECURRING',
                        frequency: 'YEARLY',
                        weekday: 0,
                        monthday: configuredPaymentDay,
                        payday: String(configuredPaymentDay),
                        targetLiquidAssetId: sourceAsset.insurancePaymentAccountId,
                        linkedAssetId: assetId,
                        linkedSource: 'INSURANCE_DISTRIBUTION_AUTO'
                    };
                };

                const resolveFixedDepositMaturityDateKey = (sourceAsset) => {
                    const startDate = parseDateKey(sourceAsset.fixedDepositStartDate) || new Date();
                    const termMonths = Math.max(1, Math.floor(Number(sourceAsset.fixedDepositMonths || 0) || 0));
                    const targetMonthDate = new Date(startDate.getFullYear(), startDate.getMonth() + termMonths, 1);
                    const daysInTargetMonth = new Date(targetMonthDate.getFullYear(), targetMonthDate.getMonth() + 1, 0).getDate();
                    const targetDay = Math.min(startDate.getDate(), daysInTargetMonth);
                    return toDateKey(new Date(targetMonthDate.getFullYear(), targetMonthDate.getMonth(), targetDay));
                };

                const buildFixedDepositMaturityCashflowEntry = (assetId, sourceAsset, existingCashflowId = '') => {
                    const selectedLiquidAsset = liquidAssetOptions.find(option => option.id === sourceAsset.fixedDepositTargetLiquidAssetId);
                    const maturityDateKey = resolveFixedDepositMaturityDateKey(sourceAsset);
                    const maturityDate = parseDateKey(maturityDateKey) || new Date();
                    const maturityDay = maturityDate.getDate();
                    const maturityAmount = Number(sourceAsset.fixedDepositMaturityAmount || sourceAsset.currentPrice || 0);
                    return {
                        id: existingCashflowId || `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        title: (sourceAsset.name || '').trim() ? `${(sourceAsset.name || '').trim()} 到期入帳` : '定期存款到期入帳',
                        account: selectedLiquidAsset?.account || sourceAsset.account || '',
                        category: getDefaultCashflowCategory('INCOME'),
                        note: [
                            tByLang('定期存款到期（自動）', 'Fixed Deposit Maturity (Auto)', '定期預金満期（自動）'),
                            tByLang('本金＋利息', 'Principal + Interest', '元本＋利息')
                        ].join('｜'),
                        type: 'INCOME',
                        amount: maturityAmount,
                        currency: sourceAsset.currency || 'HKD',
                        startDate: maturityDateKey,
                        oneTimeDates: [maturityDateKey],
                        endDate: '',
                        scheduleType: 'ONE_TIME',
                        frequency: 'ONE_TIME',
                        weekday: 0,
                        monthday: maturityDay,
                        payday: String(maturityDay),
                        targetLiquidAssetId: sourceAsset.fixedDepositTargetLiquidAssetId,
                        linkedAssetId: assetId,
                        linkedSource: 'FIXED_DEPOSIT_MATURITY_AUTO'
                    };
                };

                const resolveBankWealthMaturityDateKey = (sourceAsset) => {
                    const explicitMaturityDate = parseDateKey(sourceAsset.bankWealthMaturityDate || '');
                    if (explicitMaturityDate) return toDateKey(explicitMaturityDate);
                    const startDate = parseDateKey(sourceAsset.bankWealthStartDate) || new Date();
                    const termDays = Math.max(1, Math.floor(Number(sourceAsset.bankWealthTermDays || 0) || 0));
                    const maturity = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + termDays);
                    return toDateKey(maturity);
                };

                const buildBankWealthMaturityCashflowEntry = (assetId, sourceAsset, existingCashflowId = '') => {
                    const selectedLiquidAsset = liquidAssetOptions.find(option => option.id === sourceAsset.bankWealthTargetLiquidAssetId);
                    const maturityDateKey = resolveBankWealthMaturityDateKey(sourceAsset);
                    const maturityDate = parseDateKey(maturityDateKey) || new Date();
                    const maturityDay = maturityDate.getDate();
                    const payoutMode = sourceAsset.bankWealthMaturityPayoutMode === 'max'
                        ? 'max'
                        : (sourceAsset.bankWealthMaturityPayoutMode === 'manual' ? 'manual' : 'guaranteed');
                    const maturityAmount = (() => {
                        if (payoutMode === 'max') {
                            return Number(sourceAsset.bankWealthMaxMaturityAmount || sourceAsset.bankWealthGuaranteedMaturityAmount || sourceAsset.currentPrice || 0);
                        }
                        if (payoutMode === 'manual') {
                            return Number(sourceAsset.bankWealthMaturityManualAmount || 0);
                        }
                        return Number(sourceAsset.bankWealthGuaranteedMaturityAmount || sourceAsset.currentPrice || 0);
                    })();
                    return {
                        id: existingCashflowId || `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        title: (sourceAsset.name || '').trim() ? `${(sourceAsset.name || '').trim()} 到期入帳` : '銀行理財到期入帳',
                        account: selectedLiquidAsset?.account || sourceAsset.account || '',
                        category: getDefaultCashflowCategory('INCOME'),
                        note: [
                            tByLang('銀行理財到期（自動）', 'Bank Wealth Maturity (Auto)', '銀行理財満期（自動）'),
                            tByLang('本金＋保底收益', 'Principal + Guaranteed Yield', '元本＋最低收益')
                        ].join('｜'),
                        type: 'INCOME',
                        amount: maturityAmount,
                        currency: sourceAsset.currency || 'HKD',
                        startDate: maturityDateKey,
                        oneTimeDates: [maturityDateKey],
                        endDate: '',
                        scheduleType: 'ONE_TIME',
                        frequency: 'ONE_TIME',
                        weekday: 0,
                        monthday: maturityDay,
                        payday: String(maturityDay),
                        targetLiquidAssetId: sourceAsset.bankWealthTargetLiquidAssetId,
                        linkedAssetId: assetId,
                        linkedSource: 'BANK_WEALTH_MATURITY_AUTO'
                    };
                };

                const shouldEnableDistributionRule = Boolean(
                    needsPremium
                    && isLifeWealthInsuranceForm
                    && !['投資型壽險', '投資/投資相連'].includes(formData.subtype)
                    && formData.insuranceDistributionMode === 'cash'
                    && (Number(formData.insuranceAnnualDistributionAmount) || 0) > 0
                    && (Number(formData.insuranceDistributionStartPolicyYear) || 0) >= 1
                    && formData.insurancePaymentAccountId
                    && formData.insuranceStartDate
                );
                const resolvedPremiumAmount = (() => {
                    const basePremiumAmount = Number(formData.insuranceBasePremiumAmount || 0);
                    const supplementaryPremiumAmount = Number(formData.insuranceSupplementaryPremiumAmount || 0);
                    const hasSupplementary = formData.insuranceHasSupplementaryBenefit === 'yes';
                    if (isLifeWealthInsuranceForm && basePremiumAmount > 0) {
                        return basePremiumAmount + (hasSupplementary ? supplementaryPremiumAmount : 0);
                    }
                    return Number(formData.premiumAmount || 0);
                })();

                const partialWithdrawalAmount = Number(formData.insurancePartialWithdrawalAmount || 0);
                const partialWithdrawalEditCashflowId = (formData.insurancePartialWithdrawalEditCashflowId || '').trim();
                const partialWithdrawalEditEntry = partialWithdrawalEditCashflowId
                    ? cashflowEntries.find(entry => (
                        entry.id === partialWithdrawalEditCashflowId
                        && entry.linkedSource === 'INSURANCE_PARTIAL_WITHDRAWAL'
                        && entry.linkedAssetId === editingId
                    ))
                    : null;
                const hasPartialWithdrawal = Boolean(editingId && isLifeWealthInsuranceForm && partialWithdrawalAmount > 0);
                const partialWithdrawalTargetAccountId = formData.insurancePartialWithdrawalAccountId || formData.insurancePaymentAccountId;
                const parsedPartialWithdrawalDate = parseDateKey(formData.insurancePartialWithdrawalDate || '');
                const partialWithdrawalDateKey = parsedPartialWithdrawalDate
                    ? toDateKey(parsedPartialWithdrawalDate)
                    : toDateKey(new Date());

                const buildInsurancePartialWithdrawalCashflowEntry = (assetId, sourceAsset, existingCashflowId = '') => {
                    const selectedLiquidAsset = liquidAssetOptions.find(option => option.id === partialWithdrawalTargetAccountId);
                    const [year, month, day] = partialWithdrawalDateKey.split('-').map(Number);
                    return {
                        id: existingCashflowId || `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        title: (sourceAsset.name || '').trim() ? `${(sourceAsset.name || '').trim()} 部分提領` : '保單部分提領',
                        account: selectedLiquidAsset?.account || sourceAsset.account || '',
                        category: getDefaultCashflowCategory('INCOME'),
                        note: [
                            tByLang('保單部分提領（自動）', 'Policy Partial Withdrawal (Auto)', '保険一部引き出し（自動）'),
                            (sourceAsset.insurancePolicyNumber || '').trim(),
                            (formData.insurancePartialWithdrawalNote || '').trim()
                        ].filter(Boolean).join('｜'),
                        type: 'INCOME',
                        amount: partialWithdrawalAmount,
                        currency: sourceAsset.currency || 'HKD',
                        startDate: partialWithdrawalDateKey,
                        oneTimeDates: [partialWithdrawalDateKey],
                        endDate: '',
                        scheduleType: 'ONE_TIME',
                        frequency: 'ONE_TIME',
                        weekday: 0,
                        monthday: day || 1,
                        payday: String(day || 1),
                        targetLiquidAssetId: partialWithdrawalTargetAccountId,
                        linkedAssetId: assetId,
                        linkedSource: 'INSURANCE_PARTIAL_WITHDRAWAL'
                    };
                };

                if (needsPremium) {
                    if (!formData.insurancePaymentAccountId) {
                        showSubmissionErrorAlert(tByLang('保險請選擇扣款帳戶', 'Please select a payment account for insurance.', '保険の引落口座を選択してください。'));
                        return;
                    }
                    if (!formData.insuranceStartDate || !parseDateKey(formData.insuranceStartDate)) {
                        showSubmissionErrorAlert(tByLang('保險請輸入有效的保單生效日', 'Please enter a valid policy effective date.', '有効な保険開始日を入力してください。'));
                        return;
                    }
                    const paymentDay = Number(formData.insurancePaymentDay);
                    if (!Number.isInteger(paymentDay) || paymentDay < 1 || paymentDay > 31) {
                        showSubmissionErrorAlert(tByLang('保險請設定固定扣款日（1-31）', 'Please set a fixed debit day (1-31).', '固定引落日（1〜31）を設定してください。'));
                        return;
                    }
                    if (resolvedPremiumAmount <= 0) {
                        showSubmissionErrorAlert(tByLang('保險請輸入有效的每期保費', 'Please enter a valid premium per term.', '有効な1期あたり保険料を入力してください。'));
                        return;
                    }
                }

                if (isFixedDepositForm) {
                    if (!formData.fixedDepositTargetLiquidAssetId) {
                        showSubmissionErrorAlert(tByLang('定期存款請選擇到期入帳帳戶', 'Please select a maturity payout account for fixed deposit.', '定期預金の満期入金口座を選択してください。'));
                        return;
                    }
                    if (!formData.fixedDepositStartDate || !parseDateKey(formData.fixedDepositStartDate)) {
                        showSubmissionErrorAlert(tByLang('定期存款請輸入有效的起存日', 'Please enter a valid start date for fixed deposit.', '定期預金の有効な開始日を入力してください。'));
                        return;
                    }
                }

                if (isBankWealthForm) {
                    if (!formData.bankWealthTargetLiquidAssetId) {
                        showSubmissionErrorAlert(tByLang('銀行理財請選擇到期入帳帳戶', 'Please select a maturity payout account for bank wealth.', '銀行理財の満期入金口座を選択してください。'));
                        return;
                    }
                    if (!formData.bankWealthStartDate || !parseDateKey(formData.bankWealthStartDate)) {
                        showSubmissionErrorAlert(tByLang('銀行理財請輸入有效的起息日', 'Please enter a valid start date for bank wealth.', '銀行理財の有効な起算日を入力してください。'));
                        return;
                    }
                    if ((Number(formData.bankWealthTermDays || 0) || 0) <= 0) {
                        showSubmissionErrorAlert(tByLang('銀行理財請輸入有效的期限天數', 'Please enter valid term days for bank wealth.', '銀行理財の有効な日数を入力してください。'));
                        return;
                    }
                    if ((formData.bankWealthMaturityPayoutMode || 'guaranteed') === 'manual' && (Number(formData.bankWealthMaturityManualAmount || 0) || 0) <= 0) {
                        showSubmissionErrorAlert(tByLang('銀行理財手動到期入帳金額需大於 0', 'Manual maturity payout amount must be greater than 0.', '手動満期入金額は 0 より大きくしてください。'));
                        return;
                    }
                }

                if (hasPartialWithdrawal && !partialWithdrawalTargetAccountId) {
                    showSubmissionErrorAlert(tByLang('部分提領請選擇入帳帳戶，或先設定扣款帳戶', 'Please select a target account for partial withdrawal, or set a payment account first.', '一部引き出しの入金口座を選択するか、先に引落口座を設定してください。'));
                    return;
                }

                if (hasPartialWithdrawal) {
                    const currentPolicyValueForGuard = Number(formData.insurancePolicyValue || 0);
                    const rollbackAmountWhenEditing = Number(partialWithdrawalEditEntry?.amount || 0);
                    const maxWithdrawableAmount = Math.max(0, currentPolicyValueForGuard + rollbackAmountWhenEditing);
                    if (partialWithdrawalAmount > maxWithdrawableAmount) {
                        showSubmissionErrorAlert(tByLang(
                            `部分提領金額不可超過可提領上限：${formatAmount(maxWithdrawableAmount)} ${formData.currency}`,
                            `Withdrawal amount cannot exceed the maximum available amount: ${formatAmount(maxWithdrawableAmount)} ${formData.currency}`,
                            `引き出し金額は上限を超えられません：${formatAmount(maxWithdrawableAmount)} ${formData.currency}`
                        ));
                        return;
                    }
                }

                if (partialWithdrawalEditCashflowId && !partialWithdrawalEditEntry) {
                    showSubmissionErrorAlert(tByLang('找不到要修改的提領紀錄，請重新選擇。', 'Cannot find the withdrawal record to edit. Please select it again.', '編集対象の引き出し記録が見つかりません。再選択してください。'));
                    return;
                }

                const submission = buildAssetSubmission({
                    formData,
                    editingId,
                    isLiquidForm,
                    isCryptoForm,
                    isStockForm,
                    isFundForm,
                    isFixedDepositForm,
                    fixedDepositMetrics,
                    isBankWealthForm,
                    bankWealthMetrics,
                    needsPremium,
                    isMortgageForm,
                    mortgageMetrics,
                    isLoanForm,
                    loanMetrics,
                    isCreditCardForm,
                    isPayableForm,
                    isOtherLiabilityForm,
                    isReceivableForm,
                    isFixedForm
                });

                if (!submission.ok) {
                    showSubmissionErrorAlert(submission.error);
                    return;
                }

                let data = submission.data;
                const newAssetId = editingId || Date.now().toString();
                const shouldEnableFixedDepositMaturityRule = Boolean(
                    isFixedDepositForm
                    && data.fixedDepositTargetLiquidAssetId
                    && (Number(data.fixedDepositMaturityAmount || data.currentPrice || 0) > 0)
                );
                const shouldEnableBankWealthMaturityRule = Boolean(
                    isBankWealthForm
                    && data.bankWealthTargetLiquidAssetId
                    && (() => {
                        const payoutMode = data.bankWealthMaturityPayoutMode === 'max'
                            ? 'max'
                            : (data.bankWealthMaturityPayoutMode === 'manual' ? 'manual' : 'guaranteed');
                        if (payoutMode === 'max') return Number(data.bankWealthMaxMaturityAmount || data.bankWealthGuaranteedMaturityAmount || data.currentPrice || 0) > 0;
                        if (payoutMode === 'manual') return Number(data.bankWealthMaturityManualAmount || 0) > 0;
                        return Number(data.bankWealthGuaranteedMaturityAmount || data.currentPrice || 0) > 0;
                    })()
                );

                if (hasPartialWithdrawal) {
                    const currentPolicyValue = Number(data.insurancePolicyValue || 0);
                    const currentPriceValue = Number(data.currentPrice || 0);
                    const previousAmount = Number(partialWithdrawalEditEntry?.amount || 0);
                    const adjustmentAmount = partialWithdrawalEditEntry
                        ? (partialWithdrawalAmount - previousAmount)
                        : partialWithdrawalAmount;
                    const nextPolicyValue = Math.max(0, currentPolicyValue - adjustmentAmount);
                    const nextCurrentPrice = Math.max(0, currentPriceValue - adjustmentAmount);
                    data = {
                        ...data,
                        insurancePolicyValue: nextPolicyValue,
                        currentPrice: nextCurrentPrice
                    };
                }

                if (editingId) {
                    setAssets(assets.map(a => a.id === editingId ? { ...data, id: editingId } : a));

                    setCashflowEntries(prev => {
                        const upsertBySource = (entries, source, createEntry) => {
                            const index = entries.findIndex(entry => entry.linkedSource === source && entry.linkedAssetId === editingId);
                            const existingId = index >= 0 ? (entries[index].id || '') : '';
                            const nextEntry = createEntry(existingId);
                            if (index >= 0) {
                                return entries.map((entry, i) => (i === index ? nextEntry : entry));
                            }
                            return [...entries, nextEntry];
                        };

                        const removeBySource = (entries, source) => entries.filter(entry => !(entry.linkedSource === source && entry.linkedAssetId === editingId));

                        let nextEntries = prev;
                        if (needsPremium) {
                            nextEntries = upsertBySource(nextEntries, 'INSURANCE_AUTO', (existingId) => buildInsuranceCashflowEntry(editingId, data, existingId));
                        } else if (wasAutoInsurance) {
                            nextEntries = removeBySource(nextEntries, 'INSURANCE_AUTO');
                        }

                        if (shouldEnableDistributionRule) {
                            nextEntries = upsertBySource(nextEntries, 'INSURANCE_DISTRIBUTION_AUTO', (existingId) => buildInsuranceDistributionCashflowEntry(editingId, data, existingId));
                        } else if (wasAutoInsurance) {
                            nextEntries = removeBySource(nextEntries, 'INSURANCE_DISTRIBUTION_AUTO');
                        }

                        if (shouldEnableFixedDepositMaturityRule) {
                            nextEntries = upsertBySource(nextEntries, 'FIXED_DEPOSIT_MATURITY_AUTO', (existingId) => buildFixedDepositMaturityCashflowEntry(editingId, data, existingId));
                        } else if (wasAutoFixedDeposit) {
                            nextEntries = removeBySource(nextEntries, 'FIXED_DEPOSIT_MATURITY_AUTO');
                        }

                        if (shouldEnableBankWealthMaturityRule) {
                            nextEntries = upsertBySource(nextEntries, 'BANK_WEALTH_MATURITY_AUTO', (existingId) => buildBankWealthMaturityCashflowEntry(editingId, data, existingId));
                        } else if (wasAutoBankWealth) {
                            nextEntries = removeBySource(nextEntries, 'BANK_WEALTH_MATURITY_AUTO');
                        }

                        if (hasPartialWithdrawal) {
                            if (partialWithdrawalEditEntry) {
                                nextEntries = nextEntries.map(entry => (
                                    entry.id === partialWithdrawalEditEntry.id
                                        ? buildInsurancePartialWithdrawalCashflowEntry(editingId, data, partialWithdrawalEditEntry.id)
                                        : entry
                                ));
                            } else {
                                nextEntries = [...nextEntries, buildInsurancePartialWithdrawalCashflowEntry(editingId, data)];
                            }
                        }

                        return sanitizeCashflowEntries(nextEntries);
                    });
                } else {
                    setAssets([...assets, { ...data, id: newAssetId }]);

                    setCashflowEntries(prev => {
                        let nextEntries = prev;
                        if (needsPremium) {
                            nextEntries = [...nextEntries, buildInsuranceCashflowEntry(newAssetId, data)];
                        }
                        if (shouldEnableDistributionRule) {
                            nextEntries = [...nextEntries, buildInsuranceDistributionCashflowEntry(newAssetId, data)];
                        }
                        if (shouldEnableFixedDepositMaturityRule) {
                            nextEntries = [...nextEntries, buildFixedDepositMaturityCashflowEntry(newAssetId, data)];
                        }
                        if (shouldEnableBankWealthMaturityRule) {
                            nextEntries = [...nextEntries, buildBankWealthMaturityCashflowEntry(newAssetId, data)];
                        }
                        return sanitizeCashflowEntries(nextEntries);
                    });
                }

                setIsModalOpen(false);
                setEditingId(null);
                setFormData(createInitialAssetFormData());
            };

            const netWorthTier = getNetWorthTier(totals.netWorthHKD, themeId, pageLanguage);
            const netWorthTierIndex = Number.isInteger(netWorthTier?.tierIndex) ? netWorthTier.tierIndex : 0;
            const netWorthCardStyle = useMemo(() => buildNetworthCardStyle(themeId, netWorthTierIndex), [themeId, netWorthTierIndex]);
            const totalAssetsCardStyle = useMemo(() => buildSummaryCardStyle(themeId, netWorthTierIndex, 'asset'), [themeId, netWorthTierIndex]);
            const totalLiabilitiesCardStyle = useMemo(() => buildSummaryCardStyle(themeId, netWorthTierIndex, 'liability'), [themeId, netWorthTierIndex]);
            const overviewPanelCardStyle = useMemo(() => buildSummaryCardStyle(themeId, netWorthTierIndex, 'asset'), [themeId, netWorthTierIndex]);
            const detailDonutCenterCardStyle = useMemo(() => buildSummaryCardStyle(themeId, netWorthTierIndex, 'growth'), [themeId, netWorthTierIndex]);
            const selectedMixItemStyle = useMemo(() => buildMixSelectedStyle(themeId, netWorthTierIndex), [themeId, netWorthTierIndex]);
            const accountChartCenterStyle = useMemo(() => {
                const safeTier = Math.max(0, Math.min(13, Number(netWorthTierIndex) || 0));
                const resolvedThemeId = resolveThemeFamily(themeId);
                const paletteByTheme = {
                    'macaron-prince': ['--primary', '--accent', '--gold'],
                    'mint-prince': ['--primary', '--accent', '--gold'],
                    'lavender-prince': ['--accent', '--card-net-end', '--gold']
                };
                const selectedPalette = paletteByTheme[resolvedThemeId] || paletteByTheme['macaron-prince'];
                const mainVar = selectedPalette[safeTier % selectedPalette.length];
                const subVar = selectedPalette[(safeTier + 1) % selectedPalette.length];
                return {
                    holeFill: getThemeToken('--panel-bg', '#FFFFFF'),
                    ringStroke: getThemeToken('--header-border', '#FFFFFF'),
                    labelFill: `color-mix(in srgb, var(${subVar}) 34%, var(--text-sub, #64748B) 66%)`,
                    valueFill: `color-mix(in srgb, var(${mainVar}) 48%, var(--text-main, #334155) 52%)`,
                    hintFill: `color-mix(in srgb, var(${subVar}) 42%, var(--text-sub, #64748B) 58%)`
                };
            }, [themeId, netWorthTierIndex]);

            return (
                <div className="max-w-6xl mx-auto p-4 md:p-8">
                    <AppHeaderView
                        pageText={pageText}
                        tByLang={tByLang}
                        appName={appName}
                        currentHeaderSlogan={currentHeaderSlogan}
                        importInputRef={importInputRef}
                        handleImportData={handleImportData}
                        setEditingId={setEditingId}
                        setIsModalOpen={setIsModalOpen}
                        startNewCashflowEntry={startNewCashflowEntry}
                        showSettings={showSettings}
                        setShowSettings={setShowSettings}
                        authUser={authUser}
                        handleGoogleLogout={handleGoogleLogout}
                        handleGoogleLogin={handleGoogleLogin}
                        isAuthLoading={isAuthLoading}
                        isCloudSyncing={isCloudSyncing}
                        handleCloudDownload={handleCloudDownload}
                        handleCloudUpload={handleCloudUpload}
                        displayCurrency={displayCurrency}
                        setDisplayCurrency={setDisplayCurrency}
                        markRecentCurrency={markRecentCurrency}
                        orderedCurrencies={orderedCurrencies}
                        pageLanguage={pageLanguage}
                        setPageLanguage={setPageLanguage}
                        PAGE_LANGUAGE_OPTIONS={PAGE_LANGUAGE_OPTIONS}
                        themeId={themeId}
                        setThemeId={setThemeId}
                        themeOptions={themeOptions}
                        handleExportData={handleExportData}
                        openImportPicker={openImportPicker}
                        resetToSeed={resetToSeed}
                        updateMarketAndRates={updateMarketAndRates}
                        isUpdatingPrice={isUpdatingPrice}
                        isUpdatingRates={isUpdatingRates}
                        handleShareApp={handleShareApp}
                        isGeneratingPdf={isGeneratingPdf}
                        priceStatus={priceStatus}
                        lastPriceUpdate={lastPriceUpdate}
                        lastRateUpdate={lastRateUpdate}
                        cloudStatus={cloudStatus}
                        formatDateTime={formatDateTime}
                    />

                    <OverviewSectionView
                        pageText={pageText}
                        displayCurrency={displayCurrency}
                        netWorthCardStyle={netWorthCardStyle}
                        totalAssetsCardStyle={totalAssetsCardStyle}
                        totalLiabilitiesCardStyle={totalLiabilitiesCardStyle}
                        totals={totals}
                        formatAmount={formatAmount}
                        netWorthTier={netWorthTier}
                        overviewPanelCardStyle={overviewPanelCardStyle}
                        assetMix={assetMix}
                        selectedMixCategory={selectedMixCategory}
                        setSelectedMixCategory={setSelectedMixCategory}
                        selectedMixItemStyle={selectedMixItemStyle}
                        detailMix={detailMix}
                        detailDonutCenterCardStyle={detailDonutCenterCardStyle}
                    />

                    <FinanceSectionView
                        financeSectionTab={financeSectionTab}
                        setFinanceSectionTab={setFinanceSectionTab}
                        pageText={pageText}
                        selectedStatsCategory={selectedStatsCategory}
                        setSelectedStatsCategory={setSelectedStatsCategory}
                        setSelectedStatsAccount={setSelectedStatsAccount}
                        setSelectedStatsSegmentKey={setSelectedStatsSegmentKey}
                        CATEGORY_KEYS={CATEGORY_KEYS}
                        translate={translate}
                        CATEGORIES={CATEGORIES}
                        statsBreakdownMode={statsBreakdownMode}
                        setStatsBreakdownMode={setStatsBreakdownMode}
                        accountStats={accountStats}
                        tByLang={tByLang}
                        accountChartCenterStyle={accountChartCenterStyle}
                        describeArc={describeArc}
                        selectedMixItemStyle={selectedMixItemStyle}
                        overviewPanelCardStyle={overviewPanelCardStyle}
                        formatAmount={formatAmount}
                        displayCurrency={displayCurrency}
                        MonthPicker={MonthPicker}
                        selectedCashflowMonth={selectedCashflowMonth}
                        setSelectedCashflowMonth={setSelectedCashflowMonth}
                        toMonthKey={toMonthKey}
                        pageLanguage={pageLanguage}
                        moveCashflowMonth={moveCashflowMonth}
                        CashflowOverviewView={CashflowOverviewView}
                        cashflowMonthData={cashflowMonthData}
                        cashflowYearData={cashflowYearData}
                        cashflowView={cashflowView}
                        setCashflowView={setCashflowView}
                        WEEKDAY_LABELS={WEEKDAY_LABELS}
                        CashflowRulesView={CashflowRulesView}
                        cashflowEntries={cashflowEntries}
                        filteredCashflowEntries={filteredCashflowEntries}
                        cashflowRuleKeyword={cashflowRuleKeyword}
                        setCashflowRuleKeyword={setCashflowRuleKeyword}
                        cashflowRuleFilter={cashflowRuleFilter}
                        setCashflowRuleFilter={setCashflowRuleFilter}
                        cashflowRuleSortMode={cashflowRuleSortMode}
                        setCashflowRuleSortMode={setCashflowRuleSortMode}
                        editingCashflowId={editingCashflowId}
                        cancelCashflowEdit={cancelCashflowEdit}
                        setCashflowRulesVisibleCount={setCashflowRulesVisibleCount}
                        cashflowRulesVisibleCount={cashflowRulesVisibleCount}
                        CASHFLOW_TYPES={CASHFLOW_TYPES}
                        CASHFLOW_FREQUENCIES={CASHFLOW_FREQUENCIES}
                        liquidAssetLabelById={liquidAssetLabelById}
                        cashflowTriggerInfoById={cashflowTriggerInfoById}
                        fromHKD={fromHKD}
                        toHKD={toHKD}
                        startNewAssetEntry={startNewAssetEntry}
                        startNewCashflowEntry={startNewCashflowEntry}
                        startEditCashflowEntry={startEditCashflowEntry}
                        handleDeleteCashflowEntry={handleDeleteCashflowEntry}
                    />

                    <AssetFilterBarView
                        setSelectedCategories={setSelectedCategories}
                        CATEGORY_KEYS={CATEGORY_KEYS}
                        selectedCategories={selectedCategories}
                        buildCategoryChipStyle={buildCategoryChipStyle}
                        getThemeTokenByTheme={getThemeTokenByTheme}
                        tByLang={tByLang}
                        toggleCategory={toggleCategory}
                        categoryMixHexByKey={categoryMixHexByKey}
                        translate={translate}
                        CATEGORIES={CATEGORIES}
                        sortMode={sortMode}
                        setSortMode={setSortMode}
                        viewMode={viewMode}
                        setViewMode={setViewMode}
                    />

                    {viewMode === 'SUMMARY' ? (
                        <AssetSummaryListView
                            groupedAssets={groupedAssets}
                            toHKD={toHKD}
                            fromHKD={fromHKD}
                            displayCurrency={displayCurrency}
                            CATEGORIES={CATEGORIES}
                            categoryMixHexByKey={categoryMixHexByKey}
                            translate={translate}
                            formatAmount={formatAmount}
                        />
                    ) : (
                        <AssetDetailListView
                            groupedAssets={groupedAssets}
                            categoryMixHexByKey={categoryMixHexByKey}
                            translate={translate}
                            CATEGORIES={CATEGORIES}
                            toHKD={toHKD}
                            fromHKD={fromHKD}
                            displayCurrency={displayCurrency}
                            expandedAccounts={expandedAccounts}
                            toggleAccountExpand={toggleAccountExpand}
                            formatAmount={formatAmount}
                            openEdit={openEdit}
                            tByLang={tByLang}
                            cashflowAutoRulesByLiquidAssetId={cashflowAutoRulesByLiquidAssetId}
                            insuranceAutoPaidCountByAssetId={insuranceAutoPaidCountByAssetId}
                            insurancePartialWithdrawalStatsByAssetId={insurancePartialWithdrawalStatsByAssetId}
                            CASHFLOW_FREQUENCIES={CASHFLOW_FREQUENCIES}
                            onInsuranceFundRowFieldChange={handleInsuranceFundRowFieldChange}
                            onInsuranceFundAppendRowWithData={handleInsuranceFundAppendRowWithData}
                            onInsuranceFundRemoveRow={handleInsuranceFundRemoveRow}
                            onInsuranceFundMoveRow={handleInsuranceFundMoveRow}
                            onInsuranceFundDuplicateRow={handleInsuranceFundDuplicateRow}
                            onInsuranceFundClearRows={handleInsuranceFundClearRows}
                            fundCurrencyOptions={orderedCurrencies}
                            chartPalette={detailMixPalette}
                            liquidAssetLabelById={liquidAssetLabelById}
                        />
                    )}

                    <AppModalsView
                        AssetModalView={AssetModalView}
                        CashflowModalView={CashflowModalView}
                        CashflowRuleForm={CashflowRuleForm}
                        isModalOpen={isModalOpen}
                        editingId={editingId}
                        setIsModalOpen={setIsModalOpen}
                        handleSubmit={handleSubmit}
                        FIELD_LABEL_CLASS={FIELD_LABEL_CLASS}
                        MODAL_INPUT_CLASS={MODAL_INPUT_CLASS}
                        MODAL_INPUT_FOCUS_CLASS={MODAL_INPUT_FOCUS_CLASS}
                        MODAL_OUTPUT_CLASS={MODAL_OUTPUT_CLASS}
                        MODAL_GROUP_CLASS={MODAL_GROUP_CLASS}
                        isLiquidForm={isLiquidForm}
                        isInvestForm={isInvestForm}
                        isCryptoForm={isCryptoForm}
                        isStockForm={isStockForm}
                        isFundForm={isFundForm}
                        isFixedDepositForm={isFixedDepositForm}
                        isBankWealthForm={isBankWealthForm}
                        isMortgageForm={isMortgageForm}
                        isLoanForm={isLoanForm}
                        isCreditCardForm={isCreditCardForm}
                        isPayableForm={isPayableForm}
                        isOtherLiabilityForm={isOtherLiabilityForm}
                        isLiabilityForm={isLiabilityForm}
                        isReceivableForm={isReceivableForm}
                        isFixedForm={isFixedForm}
                        needsPremium={needsPremium}
                        isHealthInsuranceForm={isHealthInsuranceForm}
                        isLifeWealthInsuranceForm={isLifeWealthInsuranceForm}
                        formData={formData}
                        updateFormField={updateFormField}
                        updateFormFieldUpper={updateFormFieldUpper}
                        CATEGORIES={CATEGORIES}
                        handleAssetCategoryChange={handleAssetCategoryChange}
                        handleAssetSubtypeChange={handleAssetSubtypeChange}
                        fixedDepositMetrics={fixedDepositMetrics}
                        bankWealthMetrics={bankWealthMetrics}
                        mortgageMetrics={mortgageMetrics}
                        loanMetrics={loanMetrics}
                        formatAmount={formatAmount}
                        premiumTotal={premiumTotal}
                        orderedCurrencies={orderedCurrencies}
                        handleDelete={handleDelete}
                        insurancePartialWithdrawalRecords={editingId ? (insurancePartialWithdrawalRecordsByAssetId[editingId] || []) : []}
                        loadInsurancePartialWithdrawalRecordForEdit={loadInsurancePartialWithdrawalRecordForEdit}
                        clearInsurancePartialWithdrawalEditTarget={clearInsurancePartialWithdrawalEditTarget}
                        deleteInsurancePartialWithdrawalRecord={deleteInsurancePartialWithdrawalRecord}
                        pageLanguage={pageLanguage}
                        isCashflowModalOpen={isCashflowModalOpen}
                        setIsCashflowModalOpen={setIsCashflowModalOpen}
                        editingCashflowId={editingCashflowId}
                        setEditingCashflowId={setEditingCashflowId}
                        cashflowFormRef={cashflowFormRef}
                        handleCashflowSubmit={handleCashflowSubmit}
                        cashflowEntries={cashflowEntries}
                        cashflowAccountOptions={cashflowAccountOptions}
                        CASHFLOW_INPUT_CLASS={CASHFLOW_INPUT_CLASS}
                        CASHFLOW_INPUT_FOCUS_CLASS={CASHFLOW_INPUT_FOCUS_CLASS}
                        cashflowForm={cashflowForm}
                        updateCashflowField={updateCashflowField}
                        toggleCashflowOneTimeDate={toggleCashflowOneTimeDate}
                        updateCashflowOneTimeMonth={updateCashflowOneTimeMonth}
                        applyCashflowOneTimeMonthPreset={applyCashflowOneTimeMonthPreset}
                        clearCashflowOneTimeDates={clearCashflowOneTimeDates}
                        updateCashflowType={updateCashflowType}
                        updateCashflowTargetLiquidAsset={updateCashflowTargetLiquidAsset}
                        CASHFLOW_TYPES={CASHFLOW_TYPES}
                        CASHFLOW_SCHEDULE_TYPES={CASHFLOW_SCHEDULE_TYPES}
                        liquidAssetOptions={liquidAssetOptions}
                        isCashflowOneTime={isCashflowOneTime}
                        isCashflowMonthlyRecurring={isCashflowMonthlyRecurring}
                        CASHFLOW_FREQUENCIES={CASHFLOW_FREQUENCIES}
                        availableCashflowCategories={availableCashflowCategories}
                        parseDateKey={parseDateKey}
                        toDateKey={toDateKey}
                    />

                    <AppFooterView princeHintMessage={princeHintMessage} appName={appName} />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>